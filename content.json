{"meta":{"title":"机会是留给有准备的人的~","subtitle":null,"description":null,"author":"wyx","url":"http://yoursite.com"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2017-12-07T03:32:47.000Z","updated":"2017-05-12T16:12:48.000Z","comments":false,"path":"/404.html","permalink":"http://yoursite.com//404.html","excerpt":"","text":".article-header { padding: 0; padding-top: 26px; border-left: none; text-align: center; } .article-header:hover { border-left: none; } .article-title { font-size: 2.1em; } strong a { color: #747474; } .article-meta { display: none; } .share { display: none; } .ds-meta { display: none; } .player { margin-left: -10px; } .sign { text-align: right; font-style: italic; } #page-visit { display: none; } .center { text-align: center; height: 2.5em; font-weight: bold; } .article-entry hr { margin: 0; } .pic { text-align: center; margin: 0; } .pic br { display: none; } #container .article-info-post.article-info { display: none; } #container .article .article-title { padding: 0; }"},{"title":"分类","date":"2014-12-22T04:39:04.000Z","updated":"2017-05-12T16:12:00.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tagcloud","date":"2017-05-12T15:32:39.000Z","updated":"2017-05-12T16:11:42.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"test","slug":"text","date":"2017-12-02T05:17:02.000Z","updated":"2017-12-08T06:22:49.000Z","comments":true,"path":"2017/12/02/text/","link":"","permalink":"http://yoursite.com/2017/12/02/text/","excerpt":"","text":"正文开始Vue实例详解与生命周期 二级标题1console.log(111); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586这里是最终敲完的正确代码，可用于比对&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=\"UTF-8\"/&gt; &lt;script src=\"test.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; function WhoisE () &#123; var e; e = document.getElementsByClassName(\"classA\"); e = document.getElementsByTagName(\"div\"); e = document.getElementById(\"d1\"); e.setAttribute(\"align\",\"center\"); e.setAttribute(\"data-test\",\"2\"); e.style.fontFamily=\"微软雅黑\"; e.style.backgroundImage=\"url(img/HBuilder.png)\"; e.style.cssText=\"background-image: url(img/HBuilder.png);\"; switch (e.style.display)&#123; case \"-webkit-box\": break; default: break; &#125; if (e.getAttribute(\"class\")!=\"classA\") &#123; e.className=\"classA\"; &#125; e.innerHTML=\"&lt;font color='#CCCCCC'&gt;&lt;/font&gt;\"; e = document.getElementById(\"a1\"); e.href=\"#a1\"; e.target=\"_blank\"; e = new Image(); e.src=\"img/HBuilder.png\"; e = window.indexedDB || window.webkitIndexedDB || window.msIndexedDB || window.mozIndexedDB; if (typeof(e)!=\"undefined\") &#123; e.open(\"test\"); &#125; var head = document.getElementsByTagName(\"head\")[0]; with (head)&#123; var l = lastElementChild; removeChild(l); &#125; e = document.createElement(\"link\"); e.rel=\"stylesheet\"; e.type=\"text/css\"; e.href=\"test.css\"; head.appendChild(e); var ss=\"e is \"; if (e.getAttribute(\"data-test\")==null) &#123; ss=ss+e.outerHTML; &#125; else&#123; ss=ss+\"unknow\"; &#125; alert(ss) &#125; addEventListener(\"DOMContentLoaded\",function () &#123; finishLesson(1) &#125;) &lt;/script&gt; &lt;style type=\"text/css\"&gt; body&#123; text-align: center; -webkit-user-select: none; &#125; input[type=button]&#123; width: 90px; &#125; ul&#123;display: none&#125; #d1&#123; font-family: \"微软雅黑\"; background-image: url(img/HBuilder.png) &#125; &lt;/style&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"test.css\"/&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=\"img/HBuilder.png\"/&gt; &lt;br /&gt; &lt;div id=\"d1\" class=\"classA\" data-test = \"1\"&gt;&lt;/div&gt; &lt;a href=\"#a1\" id=\"a1\"&gt;&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;nav&gt;&amp;nbsp;&lt;/nav&gt; &lt;input type=\"button\" name=\"\" id=\"\" value=\"who is e\" onclick=\"WhoisE()\" /&gt; &lt;/body&gt;&lt;/html&gt; 哈哈哈哈哈哈 二级标题子标题呵呵呵呵呵呵呵百度 222","categories":[{"name":"油田","slug":"油田","permalink":"http://yoursite.com/categories/油田/"}],"tags":[{"name":"任丘","slug":"任丘","permalink":"http://yoursite.com/tags/任丘/"}]},{"title":"Airbnb JavaScript风格指南（）","slug":"javascript风格指南","date":"2017-11-06T02:11:26.000Z","updated":"2017-11-06T07:00:48.000Z","comments":true,"path":"2017/11/06/javascript风格指南/","link":"","permalink":"http://yoursite.com/2017/11/06/javascript风格指南/","excerpt":"","text":"正文部分JavaScript风格指南 一种最合理的JavaScript方法 其他风格指南 ES5 React CSS和Sass Ruby 类型1.1.1 基本数据类型：当你访问一个基本数据类型时，你直接使用它的值。 string number boolean null undefined 123456const foo = 1;let bar = foo;bar = 9;console.log(foo, bar); // =&gt; 1, 9 1.1.2 复杂：当你访问一个复杂的类型时，你需要引用它的值。 object array function 123456const foo = [1, 2];const bar = foo;bar[0] = 9;console.log(foo[0], bar[0]); // =&gt; 9, 9 ⬆回到顶部 引用 1.2.1使用const您的所有引用的; 避免使用var。eslint： prefer-const，no-const-assign为什么？这可以确保您不能重新分配您的引用，这可能会导致错误和难以理解的代码。 1234567// badvar a = 1;var b = 2;// goodconst a = 1;const b = 2; 1.2.2如果您必须重新分配引用，请使用let而不是var。eslint：no-varjscs：disallowVar为什么？let是块范围的而不是函数范围的var。 12345// badvar count = 1;if (true) &#123; count += 1;&#125; 1.2.3注意，两个let和const是块作用域。 1234567// const and let only exist in the blocks they are defined in.&#123; let a = 1; const b = 1;&#125;console.log(a); // ReferenceErrorconsole.log(b); // ReferenceError ⬆回到顶部 对象 1.3.1使用文字语法创建对象。eslint：no-new-object 12345// badconst item = new Object();// goodconst item = &#123;&#125;; 1.3.2如果您的代码将在脚本上下文中的浏览器中执行，请不要使用保留字作为键。它不会在IE8中工作。更多信息。在ES6模块和服务器端代码中使用它们是可以的。JSCS：disallowIdentifierNames 1234567891011// badconst superman = &#123; default: &#123; clark: 'kent' &#125;, private: true,&#125;;// goodconst superman = &#123; defaults: &#123; clark: 'kent' &#125;, hidden: true,&#125;; 1.3.3使用可读的同义词代替保留字。JSCS：disallowIdentifierNames 1234567891011121314// badconst superman = &#123; class: 'alien',&#125;;// badconst superman = &#123; klass: 'alien',&#125;;// goodconst superman = &#123; type: 'alien',&#125;; 1.3.4使用动态属性名称创建对象时使用计算的属性名称。为什么？它们允许你在一个地方定义一个对象的所有属性。 123456789function getKey(k) &#123; return a key named $&#123;k&#125;; &#125;// bad const obj = &#123; id: 5, name: 'San Francisco'&#125;; obj[getKey('enabled')] = true;// good const obj = &#123; id: 5, name: 'San Francisco', [getKey('enabled')]: true&#125;; 1.3.5使用对象方法速记。eslint：object-shorthandjscs：requireEnhancedObjectLiterals 1234567891011121314151617// badconst atom = &#123; value: 1, addValue: function (value) &#123; return atom.value + value; &#125;,&#125;;// goodconst atom = &#123; value: 1, addValue(value) &#123; return atom.value + value; &#125;,&#125;; 1.3.6使用属性值速记。eslint：object-shorthandjscs：requireEnhancedObjectLiterals为什么？写和描述性较短。 1234567891011const lukeSkywalker = 'Luke Skywalker';// badconst obj = &#123; lukeSkywalker: lukeSkywalker,&#125;;// goodconst obj = &#123; lukeSkywalker,&#125;; 1.3.7 在你的对象声明的开头分组你的速记属性。为什么？判断哪些属性使用简写更容易。 12345678910111213141516171819202122const anakinSkywalker = 'Anakin Skywalker';const lukeSkywalker = 'Luke Skywalker';// badconst obj = &#123; episodeOne: 1, twoJediWalkIntoACantina: 2, lukeSkywalker, episodeThree: 3, mayTheFourth: 4, anakinSkywalker,&#125;;// goodconst obj = &#123; lukeSkywalker, anakinSkywalker, episodeOne: 1, twoJediWalkIntoACantina: 2, episodeThree: 3, mayTheFourth: 4,&#125;; 1.3.8 只引用无效标识符的属性。eslint：quote-propsjscs：disallowQuotedKeysInObjects为什么？一般来说，我们认为它在主观上更容易阅读。它提高了语法高亮度，并且也被许多JS引擎更容易地优化。 12345678910111213// badconst bad = &#123;'foo': 3,'bar': 4,'data-blah': 5,&#125;;// goodconst good = &#123;foo: 3,bar: 4,'data-blah': 5,&#125;; 1.3.9不要叫Object.prototype直接的方法，如hasOwnProperty，propertyIsEnumerable和isPrototypeOf。 为什么？这些方法可能被所讨论的对象的属性所遮蔽 - 考虑{ hasOwnProperty: false }- 或者，对象可能是一个空对象（Object.create(null)）。 123456789101112// badconsole.log(object.hasOwnProperty(key));// goodconsole.log(Object.prototype.hasOwnProperty.call(object, key));// bestconst has = Object.prototype.hasOwnProperty; // cache the lookup once, in module scope./* or */const has = require('has');…console.log(has.call(object, key)); ⬆回到顶部","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"javaScript指南","slug":"javaScript指南","permalink":"http://yoursite.com/tags/javaScript指南/"},{"name":"ES6语法","slug":"ES6语法","permalink":"http://yoursite.com/tags/ES6语法/"}]},{"title":"webpack：从入门到真实项目配置","slug":"webpack从入门到真实项目配置","date":"2017-09-20T15:42:26.000Z","updated":"2017-09-20T02:57:00.000Z","comments":true,"path":"2017/09/20/webpack从入门到真实项目配置/","link":"","permalink":"http://yoursite.com/2017/09/20/webpack从入门到真实项目配置/","excerpt":"","text":"正文部分webpack：从入门到真实项目配置 该文使用的 Webpack 版本为 3.6.0，本文分两部分。第一步是简单的使用 webpack，第二部分通过一个真实项目来配置 webpack，没有使用任何的 CLI，都是一步步配置直到完成生产代码的打包。这是本项目对应的仓库，每个小节基本都对应了一次 commit。 这是本文的大纲，如果觉得有兴趣你就可以往下看了 Webpack 到底是什么自从出现模块化以后，大家可以将原本一坨代码分离到个个模块中，但是由此引发了一个问题。每个 JS 文件都需要从服务器去拿，由此会导致加载速度变慢。Webpack 最主要的目的就是为了解决这个问题，将所有小文件打包成一个或多个大文件，官网的图片很好的诠释了这个事情，除此之外，Webpack 也是一个能让你使用各种前端新技术的工具。 简单使用安装 在命令行中依次输入 1234567mkdir webpack-democd webpack-demo// 创建 package.json，这里会问一些问题，直接回车跳过就行npm init // 推荐这个安装方式，当然你也安装在全局环境下// 这种安装方式会将 webpack 放入 devDependencies 依赖中npm install --save-dev webpack 然后按照下图创建文件 在以下文件写入代码 12345678// sum.js// 这个模块化写法是 node 环境独有的，浏览器原生不支持使用module.exports = function(a, b) &#123; return a + b&#125;// index.jsvar sum = require('./sum')console.log(sum(1, 2)) 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script src=\"./build/bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 现在我们开始配置最简单的 webpack，首先创建 webpack.config.js 文件，然后写入如下代码 123456789// 自带的库const path = require('path')module.exports = &#123; entry: './app/index.js', // 入口文件 output: &#123; path: path.resolve(__dirname, 'build'), // 必须使用绝对地址，输出文件夹 filename: \"bundle.js\" // 打包后输出文件的文件名 &#125; &#125; 现在我们可以开始使用 webpack 了，在命令行中输入 1node_modules/.bin/webpack 没问题的话你应该可以看到类似的样子 可以发现原本两个 JS 文件只有 100B，但是打包后却增长到 2.66KB，这之中 webpack 肯定做了什么事情，我们去 bundle.js 文件中看看。 把代码简化以后，核心思路是这样的 123456789var array = [(function () &#123; var sum = array[1] console.log(sum(1, 2)) &#125;), (function (a,b) &#123; return a + b &#125;)]array[0]() // -&gt; 3 因为 module.export 浏览器是不支持的，所以 webpack 将代码改成浏览器能识别的样子。现在将 index.html 文件在浏览器中打开，应该也可以看到正确的 log。 我们之前是在文件夹中安装的 webpack，每次要输入 node_modules/.bin/webpack 过于繁琐，可以在 package.json 如下修改 123\"scripts\": &#123; \"start\": \"webpack\" &#125;, 然后再次执行 npm run start，可以发现和之前的效果是相同的。简单的使用到此为止，接下来我们来探索 webpack 更多的功能。 LoaderLoader 是 webpack 一个很强大功能，这个功能可以让你使用很多新的技术。 BabelBabel 可以让你使用 ES2015/16/17 写代码而不用顾忌浏览器的问题，Babel 可以帮你转换代码。首先安装必要的几个 Babel 库 1npm i --save-dev babel-loader babel-core babel-preset-env 先介绍下我们安装的三个库 babel-loader 用于让 webpack 知道如何运行 babel babel-core 可以看做编译器，这个库知道如何解析代码 babel-preset-env 这个库可以根据环境的不同转换代码 接下来更改 webpack-config.js 中的代码 123456789101112131415module.exports = &#123;// ...... module: &#123; rules: [ &#123; // js 文件才使用 babel test: /\\.js$/, // 使用哪个 loader use: 'babel-loader', // 不包括路径 exclude: /node_modules/ &#125; ] &#125;&#125; 配置 Babel 有很多方式，这里推荐使用 .babelrc 文件管理。 1234// ..babelrc&#123; \"presets\": [\"babel-preset-env\"]&#125; 现在将之前 JS 的代码改成 ES6 的写法 1234567// sum.jsexport default (a, b) =&gt; &#123; return a + b&#125;// index.jsimport sum from './sum'console.log(sum(1, 2)) 执行 npm run start，再观察 bundle.js 中的代码，可以发现代码被转换过了，并且同样可以正常 输出3。 当然 Babel 远不止这些功能，有兴趣的可以前往官网自己探索。 处理图片这一小节我们将使用 url-loader 和 file-loader，这两个库不仅可以处理图片，还有其他的功能，有兴趣的可以自行学习。 先安装库 1npm i --save-dev url-loader file-loader 创建一个 images 文件夹，放入两张图片，并且在 app 文件夹下创建一个 js 文件处理图片，目前的文件夹结构如图 123456789// addImage.jslet smallImg = document.createElement('img')// 必须 require 进来smallImg.src = require('../images/small.jpeg')document.body.appendChild(smallImg)let bigImg = document.createElement('img')bigImg.src = require('../images/big.jpeg')document.body.appendChild(bigImg) 接下来修改 webpack.config.js 代码 12345678910111213141516171819202122232425module.exports = &#123;// ... module: &#123; rules: [ // ... &#123; // 图片格式正则 test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, use: [ &#123; loader: 'url-loader', // 配置 url-loader 的可选项 options: &#123; // 限制 图片大小 10000B，小于限制会将图片转换为 base64格式 limit: 10000, // 超出限制，创建的文件格式 // build/images/[图片名].[hash].[图片格式] name: 'images/[name].[hash].[ext]' &#125; &#125; ] &#125; ] &#125; &#125; 运行 npm run start，打包成功如下图 可以发现大的图片被单独提取了出来，小的图片打包进了 bundle.js 中。 在浏览器中打开 HTML 文件，发现小图确实显示出来了，但是却没有看到大图，打开开发者工具栏，可以发现我们大图的图片路径是有问题的，所以我们又要修改 webpack.config.js 代码了。 123456789module.exports = &#123; entry: './app/index.js', // 入口文件 output: &#123; path: path.resolve(__dirname, 'build'), // 必须使用绝对地址，输出文件夹 filename: \"bundle.js\", // 打包后输出文件的文件名 publicPath: 'build/' // 知道如何寻找资源 &#125; // ... &#125; 最后运行下 npm run start，编译成功了，再次刷新下页面，可以发现这次大图被正确的显示了。下一小节我们将介绍如何处理 CSS 文件。 处理 CSS 文件添加 styles 文件夹，新增 addImage.css 文件，然后在该文件中新增代码 1234img &#123; border: 5px black solid;&#125;.test &#123;border: 5px black solid;&#125; 这一小节我们先使用 css-loader 和 style-loader 库。前者可以让 CSS 文件也支持 impost，并且会解析 CSS 文件，后者可以将解析出来的 CSS 通过标签的形式插入到 HTML 中，所以后面依赖前者。 1npm i --save-dev css-loader style-loader 首先修改 addImage.js 文件 123456789import '../styles/addImage.css'let smallImg = document.createElement('img')smallImg.src = require('../images/small.jpeg')document.body.appendChild(smallImg)// let bigImg = document.createElement('img')// bigImg.src = require('../images/big.jpeg')// document.body.appendChild(bigImg) 然后修改 webpack.config.js 代码 123456789101112131415161718module.exports = &#123;// ... module: &#123; rules: [ &#123; test: /\\.css$/, use: ['style-loader', &#123; loader: 'css-loader', options: &#123; modules: true &#125; &#125; ] &#125;, ] &#125; &#125; 运行下 npm run start，然后刷新页面，可以发现图片被正确的加上了边框，现在我们来看一下 HTML 的文件结构 从上图可以看到，我们在 addImage.css 文件中写的代码被加入到了 style 标签中，并且因为我们开启了 CSS 模块化的选项，所以 .test 被转成了唯一的哈希值，这样就解决了 CSS 的变量名重复问题。 但是将 CSS 代码整合进 JS 文件也是有弊端的，大量的 CSS 代码会造成 JS 文件的大小变大，操作 DOM 也会造成性能上的问题，所以接下来我们将使用 extract-text-webpack-plugin 插件将 CSS 文件打包为一个单独文件 首先安装 npm i --save-dev extract-text-webpack-plugin 然后修改 webpack.config.js 代码 1234567891011121314151617181920212223242526272829const ExtractTextPlugin = require(\"extract-text-webpack-plugin\")module.exports = &#123;// .... module: &#123; rules: [ &#123; test: /\\.css$/, // 写法和之前基本一致 loader: ExtractTextPlugin.extract(&#123; // 必须这样写，否则会报错 fallback: 'style-loader', use: [&#123; loader: 'css-loader', options: &#123; modules: true &#125; &#125;] &#125;) ] &#125; ] &#125;, // 插件列表 plugins: [ // 输出的文件路径 new ExtractTextPlugin(\"css/[name].[hash].css\") ] &#125; 运行下 npm run start，可以发现 CSS 文件被单独打包出来了 但是这时候刷新页面会发现图片的边框消失了，那是因为我们的 HTML 文件没有引用新的 CSS 文件，所以这里需要我们手动引入下，在下面的章节我们会通过插件的方式自动引入新的文件。 接下来，会用一个项目来继续我们的 webpack 学习，在这之前，先 clone 一下项目。该项目原地址是 这里，因为使用的 webpack 版本太低，并且依赖的库也有点问题，故我将项目拷贝了过来并修改了几个库的版本号。 请依次按照以下代码操作 1234567git clone https://github.com/KieSun/webpack-demo.gitcd webpack-demo// 切换到 0.1 标签上并创建一个新分支git checkout -b demo 0.1cd projectnpm i // 查看分支是否为 demo，没问题的话就可以进行下一步 如何在项目中使用 webpack项目中已经配置了很简单的 babel 和 webpack，直接运行 npm run start 即可 这时候你会发现这个 bundle.js 居然有这么大，这肯定是不能接受的，所以接下来章节的主要目的就是将单个文件拆分为多个文件，优化项目。 分离代码先让我们考虑下缓存机制。对于代码中依赖的库很少会去主动升级版本，但是我们自己的代码却每时每刻都在变更，所以我们可以考虑将依赖的库和自己的代码分割开来，这样用户在下一次使用应用时就可以尽量避免重复下载没有变更的代码，那么既然要将依赖代码提取出来，我们需要变更下入口和出口的部分代码。 123456789101112131415161718192021222324252627// 这是 packet.json 中 dependencies 下的const VENOR = [\"faker\", \"lodash\", \"react\", \"react-dom\", \"react-input-range\", \"react-redux\", \"redux\", \"redux-form\", \"redux-thunk\"]module.exports = &#123;// 之前我们都是使用了单文件入口// entry 同时也支持多文件入口，现在我们有两个入口// 一个是我们自己的代码，一个是依赖库的代码 entry: &#123; // bundle 和 vendor 都是自己随便取名的，会映射到 [name] 中 bundle: './src/index.js', vendor: VENOR &#125;, output: &#123; path: path.join(__dirname, 'dist'), filename: '[name].js' &#125;, // ... &#125; 现在我们 build 一下，看看是否有惊喜出现 真的有惊喜。。为什么 bundle 文件大小压根没变。这是因为 bundle 中也引入了依赖库的代码,刚才的步骤并没有抽取 bundle 中引入的代码，接下来让我们学习如何将共同的代码抽取出来。 抽取共同代码在这小节我们使用 webpack 自带的插件 CommonsChunkPlugin。 123456789101112131415161718module.exports = &#123;//... output: &#123; path: path.join(__dirname, 'dist'), // 既然我们希望缓存生效，就应该每次在更改代码以后修改文件名 // [chunkhash]会自动根据文件是否更改而更换哈希 filename: '[name].[chunkhash].js' &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; // vendor 的意义和之前相同 // manifest文件是将每次打包都会更改的东西单独提取出来，保证没有更改的代码无需重新打包，这样可以加快打包速度 names: ['vendor', 'manifest'], // 配合 manifest 文件使用 minChunks: Infinity &#125;) ]&#125;; 当我们重新 build 以后，会发现 bundle 文件很明显的减小了体积 但是我们使用哈希来保证缓存的同时会发现每次 build 都会生成不一样的文件，这时候我们引入另一个插件来帮助我们删除不需要的文件。 npm install –save-dev clean-webpack-plugin 然后修改配置文件 123456789101112module.exports = &#123;//... plugins: [ // 只删除 dist 文件夹下的 bundle 和 manifest 文件 new CleanWebpackPlugin(['dist/bundle.*.js','dist/manifest.*.js'], &#123; // 打印 log verbose: true, // 删除文件 dry: false &#125;), ]&#125;; 然后 build 的时候会发现以上文件被删除了。 因为我们现在将文件已经打包成三个 JS 了，以后也许会更多，每次新增 JS 文件我们都需要手动在 HTML 中新增标签，现在我们可以通过一个插件来自动完成这个功能。 npm install html-webpack-plugin –save-dev 然后修改配置文件 12345678910module.exports = &#123;//... plugins: [ // 我们这里将之前的 HTML 文件当做模板 // 注意在之前 HTML 文件中请务必删除之前引入的 JS 文件 new HtmlWebpackPlugin(&#123; template: 'index.html' &#125;) ]&#125;; 执行 build 操作会发现同时生成了 HTML 文件，并且已经自动引入了 JS 文件 按需加载代码在这一小节我们将学习如何按需加载代码，在这之前的 vendor 入口我发现忘记加入 router 这个库了，大家可以加入这个库并且重新 build 下，会发现 bundle 只有不到 300KB 了。 现在我们的 bundle 文件包含了我们全部的自己代码。但是当用户访问我们的首页时，其实我们根本无需让用户加载除了首页以外的代码，这个优化我们可以通过路由的异步加载来完成。 现在修改 src/router.js 12345678910111213141516171819202122232425262728293031323334353637383940414243// 注意在最新版的 V4路由版本中，更改了按需加载的方式，如果安装了 V4版，可以自行前往官网学习import React from 'react';import &#123; Router, Route, IndexRoute, hashHistory &#125; from 'react-router';import Home from './components/Home';import ArtistMain from './components/artists/ArtistMain';const rootRoute = &#123; component: Home, path: '/', indexRoute: &#123; component: ArtistMain &#125;, childRoutes: [ &#123; path: 'artists/new', getComponent(location, cb) &#123; System.import('./components/artists/ArtistCreate') .then(module =&gt; cb(null, module.default)) &#125; &#125;, &#123; path: 'artists/:id/edit', getComponent(location, cb) &#123; System.import('./components/artists/ArtistEdit') .then(module =&gt; cb(null, module.default)) &#125; &#125;, &#123; path: 'artists/:id', getComponent(location, cb) &#123; System.import('./components/artists/ArtistDetail') .then(module =&gt; cb(null, module.default)) &#125; &#125; ]&#125;const Routes = () =&gt; &#123; return ( &lt;Router history=&#123;hashHistory&#125; routes=&#123;rootRoute&#125; /&gt; );&#125;;export default Routes; 然后执行 build 命令，可以发现我们的 bundle 文件又瘦身了，并且新增了几个文件 将 HTML 文件在浏览器中打开，当点击路由跳转时，可以在开发者工具中的 Network 一栏中看到加载了一个 JS 文件。 首页 点击右上角 Random Artist 以后 自动刷新每次更新代码都需要执行依次 build，并且还要等上一会很麻烦，这一小节介绍如何使用自动刷新的功能。 首先安装插件 npm i –save-dev webpack-dev-server 然后修改 packet.json 文件 1234\"scripts\": &#123; \"build\": \"webpack\", \"dev\": \"webpack-dev-server --open\" &#125;, 现在直接执行 npm run dev 可以发现浏览器自动打开了一个空的页面，并且在命令行中也多了新的输出 等待编译完成以后，修改 JS 或者 CSS 文件，可以发现 webpack 自动帮我们完成了编译，并且只更新了需要更新的代码 但是每次重新刷新页面对于 debug 来说很不友好，这时候就需要用到模块热替换了。但是因为项目中使用了 React，并且 Vue 或者其他框架都有自己的一套 hot-loader，所以这里就略过了，有兴趣的可以自己学习下。 生成生产环境代码现在我们可以将之前所学和一些新加的插件整合在一起，build 生产环境代码。 1npm i --save-dev url-loader optimize-css-assets-webpack-plugin file-loader extract-text-webpack-plugin 修改 webpack 配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091var webpack = require('webpack');var path = require('path');var HtmlWebpackPlugin = require('html-webpack-plugin')var CleanWebpackPlugin = require('clean-webpack-plugin')var ExtractTextPlugin = require('extract-text-webpack-plugin')var OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin')const VENOR = [\"faker\", \"lodash\", \"react\", \"react-dom\", \"react-input-range\", \"react-redux\", \"redux\", \"redux-form\", \"redux-thunk\", \"react-router\"]module.exports = &#123; entry: &#123; bundle: './src/index.js', vendor: VENOR &#125;, // 如果想修改 webpack-dev-server 配置，在这个对象里面修改 devServer: &#123; port: 8081 &#125;, output: &#123; path: path.join(__dirname, 'dist'), filename: '[name].[chunkhash].js' &#125;, module: &#123; rules: [&#123; test: /\\.js$/, use: 'babel-loader' &#125;, &#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, use: [&#123; loader: 'url-loader', options: &#123; limit: 10000, name: 'images/[name].[hash:7].[ext]' &#125; &#125;] &#125;, &#123; test: /\\.css$/, loader: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use: [&#123; // 这边其实还可以使用 postcss 先处理下 CSS 代码 loader: 'css-loader' &#125;] &#125;) &#125;, ] &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: ['vendor', 'manifest'], minChunks: Infinity &#125;), new CleanWebpackPlugin(['dist/*.js'], &#123; verbose: true, dry: false &#125;), new HtmlWebpackPlugin(&#123; template: 'index.html' &#125;), // 生成全局变量 new webpack.DefinePlugin(&#123; \"process.env.NODE_ENV\": JSON.stringify(\"process.env.NODE_ENV\") &#125;), // 分离 CSS 代码 new ExtractTextPlugin(\"css/[name].[contenthash].css\"), // 压缩提取出的 CSS，并解决ExtractTextPlugin分离出的 JS 重复问题 new OptimizeCSSPlugin(&#123; cssProcessorOptions: &#123; safe: true &#125; &#125;), // 压缩 JS 代码 new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;) ]&#125;; 修改 packet.json 文件 1234\"scripts\": &#123; \"build\": \"NODE_ENV=production webpack -p\", \"dev\": \"webpack-dev-server --open\" &#125; 执行 npm run build 可以看到我们在经历了这么多步以后，将 bundle 缩小到了只有 27.1KB，像 vendor 这种常用的库我们一般可以使用 CDN 的方式外链进来。 补充webpack 配置上有些实用的小点在上文没有提到，统一在这里提一下。 12345678910111213module.exports = &#123; resolve: &#123; // 文件扩展名，写明以后就不需要每个文件写后缀 extensions: ['.js', '.css', '.json'], // 路径别名，比如这里可以使用 css 指向 static/css 路径 alias: &#123; '@': resolve('src'), 'css': resolve('static/css') &#125; &#125;, // 生成 source-map，用于打断点，这里有好几个选项 devtool: '#cheap-module-eval-source-map',&#125; 后记如果你是跟着本文一个个步骤敲下来的，那么大部分的 webpack 配置你应该都是可以看懂了，并且自己应该也知道如何去配置。谢谢大家看到这里，这是本项目对应的仓库，每个小节基本都对应了一次 commit。 文章较长，有错误也难免，如果你发现了任何问题或者我有任何表述的不明白的地方，都可以留言给我。","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"前端构建工具","slug":"前端构建工具","permalink":"http://yoursite.com/tags/前端构建工具/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"js 的正则表达式","slug":"js 的正则表达式","date":"2017-09-11T02:17:02.000Z","updated":"2017-09-11T03:55:18.000Z","comments":true,"path":"2017/09/11/js 的正则表达式/","link":"","permalink":"http://yoursite.com/2017/09/11/js 的正则表达式/","excerpt":"","text":"正文开始js 的正则表达式 正则表达式 一种几乎可以在所有的程序设计语言里和所有的计算机平台上使用的文字处理工具。它可以用来查找特定的信息（搜索），也可以用来查找并编辑特定的信息（替换）。核心是 匹配，匹配位置或者匹配字符 先简单的介绍一下语法: 基本元字符1, .： 匹配除了换行符之外的任何单个字符 2, \\： 在非特殊字符之前的反斜杠表示下一个字符是特殊的，不能从字面上解释。例如，没有前\\的&#39;b&#39;通常匹配小写&#39;b&#39;，无论它们出现在哪里。如果加了’\\’,这个字符变成了一个特殊意义的字符，反斜杠也可以将其后的特殊字符，转义为字面量。例如，模式 /a*/ 代表会匹配 0 个或者多个 a。相反，模式 /a\\*/ 将 &#39;*&#39; 的特殊性移除，从而可以匹配像 &quot;a*&quot; 这样的字符串。 3, | ： 逻辑或操作符 4, [] ：定义一个字符集合，匹配字符集合中的一个字符，在字符集合里面像 .，\\这些字符都表示其本身 5, [^]：对上面一个集合取非 6, - ：定义一个区间，例如[A-Z]，其首尾字符在 ASCII 字符集里面 数量元字符1, {m,n} ：匹配前面一个字符至少 m 次至多 n 次重复，还有{m}表示匹配 m 次，{m,}表示至少 m 次 2, + ： 匹配前面一个表达式一次或者多次，相当于 {1,}，记忆方式追加(+)，起码得有一次 3, *： 匹配前面一个表达式零次或者多次，相当于 {0,}，记忆方式乘法(*)，可以一次都没有 4, ? ： 单独使用匹配前面一个表达式零次或者一次，相当于 {0,1}，记忆方式，有吗？，有(1)或者没有(1)，如果跟在任何量词*,+,?,{}后面的时候将会使量词变为非贪婪模式（尽量匹配少的字符），默认是使用贪婪模式。比如对 “123abc” 应用 /\\d+/ 将会返回 “123”，如果使用 /\\d+?/,那么就只会匹配到 “1”。 位置元字符1, ^： 单独使用匹配表达式的开始 2, \\$ ： 匹配表达式的结束 3, \\b：匹配单词边界 4, \\B：匹配非单词边界 5, (?=p)：匹配 p 前面的位置 6, (?!p)：匹配不是 p 前面的位置 特殊元字符1, \\d：[0-9]，表示一位数字，记忆方式 digit 2, \\D：[^0-9]，表示一位非数字 3, \\s：[\\t\\v\\n\\r\\f]，表示空白符，包括空格，水平制表符（\\t），垂直制表符（\\v），换行符（\\n），回车符（\\r），换页符（\\f），记忆方式 space character 4, \\S：[^\\t\\v\\n\\r\\f]，表示非空白符 5, \\w：[0-9a-zA-Z]，表示数字大小写字母和下划线，记忆方式 word 6, \\W：[^0-9a-zA-Z]，表示非单词字符 标志字符1, g : 全局搜索 记忆方式global2, i ：不区分大小写 记忆方式 ignore3, m ：多行搜索 在 js 中的使用 支持正则的 String 对象的方法1. searchsearch 接受一个正则作为参数，如果参入的参数不是正则会隐式的使用 new RegExp(obj)将其转换成一个正则，返回匹配到子串的起始位置，匹配不到返回-1 2. match接受参数和上面的方法一致。返回值是依赖传入的正则是否包含 g ，如果没有 g 标识，那么 match 方法对 string 做一次匹配，如果没有找到任何匹配的文本时，match 会返回 null ，否则，会返回一个数组，数组第 0 个元素包含匹配到的文本，其余元素放的是正则捕获的文本，数组还包含两个对象，index 表示匹配文本在字符串中的位置，input 表示被解析的原始字符串。如果有 g 标识，则返回一个数组，包含每一次的匹配结果。 123456789101112131415161718var str = 'For more information, see Chapter 3.4.5.1';var re = /see (chapter \\d+(\\.\\d)*)/i;var found = str.match(re);console.log(found);// (3) [\"see Chapter 3.4.5.1\", \"Chapter 3.4.5.1\", \".1\", index: 22, input: \"For more information, see Chapter 3.4.5.1\"]// 0:\"see Chapter 3.4.5.1\"// 1:\"Chapter 3.4.5.1\"// 2:\".1\"// index:22// input:\"For more information, see Chapter 3.4.5.1\"// length:3// __proto__:Array(0)// 'see Chapter 3.4.5.1' 是整个匹配。// 'Chapter 3.4.5.1' 被'(chapter \\d+(\\.\\d)*)'捕获。// '.1' 是被'(\\.\\d)'捕获的最后一个值。// 'index' 属性(22) 是整个匹配从零开始的索引。// 'input' 属性是被解析的原始字符串。 123456var str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';var regexp = /[A-E]/gi;var matches_array = str.match(regexp);console.log(matches_array);// ['A', 'B', 'C', 'D', 'E', 'a', 'b', 'c', 'd', 'e'] 3. replace接受两个参数，第一个是要被替换的文本，可以是正则也可以是字符串，如果是字符串的时候不会被转换成正则，而是作为检索的直接量文本。第二个是替换成的文本，可以是字符串或者函数，字符串可以使用一些特殊的变量来替代前面捕获到的子串 变量名 代表的值 $$ 插入一个 “$”。 $&amp; 插入匹配的子串。 $` 插入当前匹配的子串左边的内容。 $’ 插入当前匹配的子串右边的内容。 $n 第一个参数是RegExp对象,n是个小于100的非负整数,那么插入第n个括号匹配的字符串。 12345var re = /(\\w+)\\s(\\w+)/;var str = \"John Smith\";var newstr = str.replace(re, \"$2, $1\");// Smith, Johnconsole.log(newstr); 如果是函数的话，函数入参如下，返回替换成的文本 变量名 代表的值 match 匹配的子串。（对应于上述的$&amp;。） p1,p2,… 假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。） offset 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1） string 被匹配的原字符串。","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/categories/正则表达式/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"剖析Vue原理&实现双向绑定MVVM","slug":"剖析Vue原理&实现双向绑定MVVM","date":"2017-09-07T06:36:02.000Z","updated":"2017-09-07T08:55:08.000Z","comments":true,"path":"2017/09/07/剖析Vue原理&实现双向绑定MVVM/","link":"","permalink":"http://yoursite.com/2017/09/07/剖析Vue原理&实现双向绑定MVVM/","excerpt":"","text":"正文开始剖析Vue原理&amp;实现双向绑定MVVM 本文能帮你做什么？1、了解vue的双向数据绑定原理以及核心代码模块2、缓解好奇心的同时了解如何实现双向绑定为了便于说明原理与实现，本文相关代码主要摘自vue源码, 并进行了简化改造，相对较简陋，并未考虑到数组的处理、数据的循环依赖等，也难免存在一些问题，欢迎大家指正。不过这些并不会影响大家的阅读和理解，相信看完本文后对大家在阅读vue源码的时候会更有帮助&lt;本文所有相关代码均在github上面可找到 https://github.com/DMQ/mvvm 相信大家对mvvm双向绑定应该都不陌生了，一言不合上代码，下面先看一个本文最终实现的效果吧，和vue一样的语法，如果还不了解双向绑定，猛戳Google 1234567891011121314151617181920212223&lt;div id=\"mvvm-app\"&gt; &lt;input type=\"text\" v-model=\"word\"&gt; &lt;p&gt;&#123;&#123;word&#125;&#125;&lt;/p&gt; &lt;button v-on:click=\"sayHi\"&gt;change model&lt;/button&gt;&lt;/div&gt;&lt;script src=\"./js/observer.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/watcher.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/compile.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/mvvm.js\"&gt;&lt;/script&gt;&lt;script&gt; var vm = new MVVM(&#123; el: '#mvvm-app', data: &#123; word: 'Hello World!' &#125;, methods: &#123; sayHi: function() &#123; this.word = 'Hi, everybody!'; &#125; &#125; &#125;);&lt;/script&gt; 效果: 几种实现双向绑定的做法目前几种主流的mvc(vm)框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。 实现数据绑定的做法有大致如下几种： 发布者-订阅者模式（backbone.js） 脏值检查（angular.js） 数据劫持（vue.js） 发布者-订阅者模式:一般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是vm.set(&#39;property&#39;, value)，这里有篇文章讲的比较详细，有兴趣可点这里这种方式现在毕竟太low了，我们更希望通过 vm.property = value 这种方式更新数据，同时自动更新视图，于是有了下面两种方式脏值检查: angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下：- DOM事件，譬如用户输入文本，点击按钮等。( ng-click )- XHR响应事件 ( $http )- 浏览器Location变更事件 ( $location )- Timer事件( $timeout , $interval )- 执行 $digest() 或 $apply()- 数据劫持: vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。数据劫持: vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。## 思路整理已经了解到vue是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一，如果不熟悉defineProperty，猛戳这里整理了一下，要实现mvvm的双向绑定，就必须要实现以下几点： 1, 实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者2, 实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数3, 实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图4, mvvm入口函数，整合以上三者 上述流程如图所示： 实现Observerok, 思路已经整理完毕，也已经比较明确相关逻辑和模块功能了，let’s do it我们知道可以利用Obeject.defineProperty()来监听属性变动那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。。相关代码可以是这样： 12345678910111213141516171819202122232425262728var data = &#123;name: 'kindeng'&#125;;observe(data);data.name = 'dmq'; // 哈哈哈，监听到值变化了 kindeng --&gt; dmqfunction observe(data) &#123; if (!data || typeof data !== 'object') &#123; return; &#125; // 取出所有属性遍历 Object.keys(data).forEach(function(key) &#123; defineReactive(data, key, data[key]); &#125;);&#125;;function defineReactive(data, key, val) &#123; observe(val); // 监听子属性 Object.defineProperty(data, key, &#123; enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() &#123; return val; &#125;, set: function(newVal) &#123; console.log('哈哈哈，监听到值变化了 ', val, ' --&gt; ', newVal); val = newVal; &#125; &#125;);&#125; 这样我们已经可以监听每个数据的变化了，那么监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法，代码改善之后是这样： 1234567891011121314151617181920212223242526272829// ... 省略function defineReactive(data, key, val) &#123; var dep = new Dep(); observe(val); // 监听子属性 Object.defineProperty(data, key, &#123; // ... 省略 set: function(newVal) &#123; if (val === newVal) return; console.log('哈哈哈，监听到值变化了 ', val, ' --&gt; ', newVal); val = newVal; dep.notify(); // 通知所有订阅者 &#125; &#125;);&#125;function Dep() &#123; this.subs = [];&#125;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub); &#125;, notify: function() &#123; this.subs.forEach(function(sub) &#123; sub.update(); &#125;); &#125;&#125;; 那么问题来了，谁是订阅者？怎么往订阅器添加订阅者？没错，上面的思路整理中我们已经明确订阅者应该是Watcher, 而且var dep = new Dep();是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就必须要在闭包内操作，所以我们可以在 getter里面动手脚： 12345678910111213141516171819// Observer.js// ...省略Object.defineProperty(data, key, &#123; get: function() &#123; // 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除 Dep.target &amp;&amp; dep.addDep(Dep.target); return val; &#125; // ... 省略&#125;);// Watcher.jsWatcher.prototype = &#123; get: function(key) &#123; Dep.target = this; this.value = data[key]; // 这里会触发属性的getter，从而添加订阅者 Dep.target = null; &#125;&#125; 这里已经实现了一个Observer了，已经具备了监听数据和数据变化通知订阅者的功能，完整代码。那么接下来就是实现Compile了 实现Compilecompile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，如图所示： 因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中 12345678910111213141516171819function Compile(el) &#123; this.$el = this.isElementNode(el) ? el : document.querySelector(el); if (this.$el) &#123; this.$fragment = this.node2Fragment(this.$el); this.init(); this.$el.appendChild(this.$fragment); &#125;&#125;Compile.prototype = &#123; init: function() &#123; this.compileElement(this.$fragment); &#125;, node2Fragment: function(el) &#123; var fragment = document.createDocumentFragment(), child; // 将原生节点拷贝到fragment while (child = el.firstChild) &#123; fragment.appendChild(child); &#125; return fragment; &#125;&#125;; compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定，详看代码及注释说明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566Compile.prototype = &#123; // ... 省略 compileElement: function(el) &#123; var childNodes = el.childNodes, me = this; [].slice.call(childNodes).forEach(function(node) &#123; var text = node.textContent; var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; // 表达式文本 // 按元素节点方式编译 if (me.isElementNode(node)) &#123; me.compile(node); &#125; else if (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123; me.compileText(node, RegExp.$1); &#125; // 遍历编译子节点 if (node.childNodes &amp;&amp; node.childNodes.length) &#123; me.compileElement(node); &#125; &#125;); &#125;, compile: function(node) &#123; var nodeAttrs = node.attributes, me = this; [].slice.call(nodeAttrs).forEach(function(attr) &#123; // 规定：指令以 v-xxx 命名 // 如 &lt;span v-text=\"content\"&gt;&lt;/span&gt; 中指令为 v-text var attrName = attr.name; // v-text if (me.isDirective(attrName)) &#123; var exp = attr.value; // content var dir = attrName.substring(2); // text if (me.isEventDirective(dir)) &#123; // 事件指令, 如 v-on:click compileUtil.eventHandler(node, me.$vm, exp, dir); &#125; else &#123; // 普通指令 compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp); &#125; &#125; &#125;); &#125;&#125;;// 指令处理集合var compileUtil = &#123; text: function(node, vm, exp) &#123; this.bind(node, vm, exp, 'text'); &#125;, // ...省略 bind: function(node, vm, exp, dir) &#123; var updaterFn = updater[dir + 'Updater']; // 第一次初始化视图 updaterFn &amp;&amp; updaterFn(node, vm[exp]); // 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher new Watcher(vm, exp, function(value, oldValue) &#123; // 一旦属性值有变化，会收到通知执行此更新函数，更新视图 updaterFn &amp;&amp; updaterFn(node, value, oldValue); &#125;); &#125;&#125;;// 更新函数var updater = &#123; textUpdater: function(node, value) &#123; node.textContent = typeof value == 'undefined' ? '' : value; &#125; // ...省略&#125;; 这里通过递归遍历保证了每个节点及子节点都会解析编译到，包括了{ { } }表达式声明的文本节点。指令的声明规定是通过特定前缀的节点属性来标记，如&lt;span v-text=\\&quot;content\\&quot; other-attr中v-text便是指令，而other-attr不是指令，只是普通的属性。监听数据、绑定更新函数的处理是在compileUtil.bind()这个方法中，通过new Watcher()添加回调来接收数据变化的通知 至此，一个简单的Compile就完成了，完整代码。接下来要看看Watcher这个订阅者的具体实现了 实现WatcherWatcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是:1、在自身实例化时往属性订阅器(dep)里面添加自己2、自身必须有一个update()方法3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。如果有点乱，可以回顾下前面的思路整理 123456789101112131415161718192021222324252627282930313233343536373839404142function Watcher(vm, exp, cb) &#123; this.cb = cb; this.vm = vm; this.exp = exp; // 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解 this.value = this.get(); &#125;Watcher.prototype = &#123; update: function() &#123; this.run(); // 属性值变化收到通知 &#125;, run: function() &#123; var value = this.get(); // 取到最新值 var oldVal = this.value; if (value !== oldVal) &#123; this.value = value; this.cb.call(this.vm, value, oldVal); // 执行Compile中绑定的回调，更新视图 &#125; &#125;, get: function() &#123; Dep.target = this; // 将当前订阅者指向自己 var value = this.vm[exp]; // 触发getter，添加自己到属性订阅器中 Dep.target = null; // 添加完毕，重置 return value; &#125;&#125;;// 这里再次列出Observer和Dep，方便理解Object.defineProperty(data, key, &#123; get: function() &#123; // 由于需要在闭包内添加watcher，所以可以在Dep定义一个全局target属性，暂存watcher, 添加完移除 Dep.target &amp;&amp; dep.addDep(Dep.target); return val; &#125; // ... 省略&#125;);Dep.prototype = &#123; notify: function() &#123; this.subs.forEach(function(sub) &#123; sub.update(); // 调用订阅者的update方法，通知变化 &#125;); &#125;&#125;; 实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。 ok, Watcher也已经实现了，完整代码。基本上vue中数据绑定相关比较核心的几个模块也是这几个，猛戳这里 , 在src 目录可找到vue源码。 最后来讲讲MVVM入口文件的相关逻辑和实现吧，相对就比较简单了~ 实现MVVMMVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 一个简单的MVVM构造器是这样子：123456function MVVM(options) &#123; this.$options = options; var data = this._data = this.$options.data; observe(data, this); this.$compile = new Compile(options.el || document.body, this)&#125; 但是这里有个问题，从代码中可看出监听的数据对象是options.data，每次需要更新视图，则必须通过var vm = new MVVM({data:{name: &#39;kindeng&#39;}}); vm._data.name = &#39;dmq&#39;; 这样的方式来改变数据。 显然不符合我们一开始的期望，我们所期望的调用方式应该是这样的：var vm = new MVVM({data: {name: &#39;kindeng&#39;}}); vm.name = &#39;dmq&#39;; 所以这里需要给MVVM实例添加一个属性代理的方法，使访问vm的属性代理为访问vm._data的属性，改造后的代码如下： 1234567891011121314151617181920212223242526function MVVM(options) &#123; this.$options = options; var data = this._data = this.$options.data, me = this; // 属性代理，实现 vm.xxx -&gt; vm._data.xxx Object.keys(data).forEach(function(key) &#123; me._proxy(key); &#125;); observe(data, this); this.$compile = new Compile(options.el || document.body, this)&#125;MVVM.prototype = &#123; _proxy: function(key) &#123; var me = this; Object.defineProperty(me, key, &#123; configurable: false, enumerable: true, get: function proxyGetter() &#123; return me._data[key]; &#125;, set: function proxySetter(newVal) &#123; me._data[key] = newVal; &#125; &#125;); &#125;&#125;; 这里主要还是利用了Object.defineProperty()这个方法来劫持了vm实例对象的属性的读写权，使读写vm实例的属性转成读写了vm._data的属性值，达到鱼目混珠的效果，哈哈 至此，全部模块和功能已经完成了，如本文开头所承诺的两点。一个简单的MVVM模块已经实现，其思想和原理大部分来自经过简化改造的vue源码，猛戳这里可以看到本文的所有相关代码。由于本文内容偏实践，所以代码量较多，且不宜列出大篇幅代码，所以建议想深入了解的童鞋可以再次结合本文源代码来进行阅读，这样会更加容易理解和掌握。 总结本文主要围绕“几种实现双向绑定的做法”、“实现Observer”、“实现Compile”、“实现Watcher”、“实现MVVM”这几个模块来阐述了双向绑定的原理和实现。并根据思路流程渐进梳理讲解了一些细节思路和比较关键的内容点，以及通过展示部分关键代码讲述了怎样一步步实现一个双向绑定MVVM。文中肯定会有一些不够严谨的思考和错误，欢迎大家指正，有兴趣欢迎一起探讨和改进~ 最后，感谢您的阅读！","categories":[{"name":"双向数据绑定","slug":"双向数据绑定","permalink":"http://yoursite.com/categories/双向数据绑定/"}],"tags":[{"name":"Vuejs","slug":"Vuejs","permalink":"http://yoursite.com/tags/Vuejs/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"双向数据绑定","slug":"双向数据绑定","permalink":"http://yoursite.com/tags/双向数据绑定/"}]},{"title":"关于eslint使用规则，和各种报错对应规则","slug":"关于eslint使用规则，和各种报错对应规则","date":"2017-09-07T02:03:02.000Z","updated":"2017-09-07T02:41:50.000Z","comments":true,"path":"2017/09/07/关于eslint使用规则，和各种报错对应规则/","link":"","permalink":"http://yoursite.com/2017/09/07/关于eslint使用规则，和各种报错对应规则/","excerpt":"","text":"正文开始关于eslint使用规则，和各种报错对应规则 在用vue2.0写项目时，由于vue-cli脚 架自动带了带了代码规范监测，稍微不小心就会出现一些Warning,这时就需要，根据自己习惯的代码规范，用一下代码进行对Eslint规范的一些忽略。下面详细介绍一下： ESLint 由 JavaScript 红宝书 作者 Nicholas C. Zakas 编写， 2013 年发布第一个版本。 NCZ 的初衷不是重复造一个轮子，而是在实际需求得不到 JSHint 团队响应 的情况下做出的选择：以可扩展、每条规则独立、不内置编码风格为理念编写一个 lint 工具。 ESLint 主要有以下特点: 默认规则包含所有 JSLint、JSHint 中存在的规则，易迁移； 规则可配置性高：可设置「警告」、「错误」两个 error 等级，或者直接禁用； 包含代码风格检测的规则（可以丢掉 JSCS 了）； 支持插件扩展、自定义规则。 下面说一下如何配置：比如，我写vue过程中，出现了下面的warning: 1WARNING Compiled with 1 warnings11:26:30http://eslint.org/docs/rules/quotes Strings must use singlequote 警告的意思就是字符串必须用单引号如下图： 这时候，你就可以在.eslintrc.js配置你的规则rule “quotes”: [1, “single”],//引号类型 `` “” ‘’Use / eslint-disable / to ignore all warnings in a file. 还有一种万能方法，就是在报错的JS文件中第一行写上 / eslint-disable / 如下图 这样就可以和Eslint携手并进了 配置(我主要用第三种方法,为了方便查看，特记录如下:) 可以通过以下三种方式配置 ESLint: 使用 .eslintrc 文件（支持 JSON 和 YAML 两种语法）； 在 package.json 中添加 eslintConfig 配置块；直接在代码文件中定义。 以下是.eslintrc 文件示例和解释：为了方便查看，特记录如下,需要用的规则，到时候直接搜索就可以了，简直开心极了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298&#123; \"env\": &#123; \"browser\": true, \"node\": true, \"commonjs\": true &#125;, \"ecmaFeatures\": &#123; // lambda表达式 \"arrowFunctions\": true, // 解构赋值 \"destructuring\": true, // class \"classes\": true, // http://es6.ruanyifeng.com/#docs/function#函数参数的默认值 \"defaultParams\": true, // 块级作用域，允许使用let const \"blockBindings\": true, // 允许使用模块，模块内默认严格模式 \"modules\": true, // 允许字面量定义对象时，用表达式做属性名 // http://es6.ruanyifeng.com/#docs/object#属性名表达式 \"objectLiteralComputedProperties\": true, // 允许对象字面量方法名简写 /*var o = &#123; method() &#123; return \"Hello!\"; &#125; &#125;; 等同于 var o = &#123; method: function() &#123; return \"Hello!\"; &#125; &#125;; */ \"objectLiteralShorthandMethods\": true, /* 对象字面量属性名简写 var foo = 'bar'; var baz = &#123;foo&#125;; baz // &#123;foo: \"bar\"&#125; // 等同于 var baz = &#123;foo: foo&#125;; */ \"objectLiteralShorthandProperties\": true, // http://es6.ruanyifeng.com/#docs/function#rest参数 \"restParams\": true, // http://es6.ruanyifeng.com/#docs/function#扩展运算符 \"spread\": true, // http://es6.ruanyifeng.com/#docs/iterator#for---of循环 \"forOf\": true, // http://es6.ruanyifeng.com/#docs/generator \"generators\": true, // http://es6.ruanyifeng.com/#docs/string#模板字符串 \"templateStrings\": true, \"superInFunctions\": true, // http://es6.ruanyifeng.com/#docs/object#对象的扩展运算符 \"experimentalObjectRestSpread\": true &#125;, \"rules\": &#123; // 定义对象的set存取器属性时，强制定义get \"accessor-pairs\": 2, // 指定数组的元素之间要以空格隔开(,后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格 \"array-bracket-spacing\": [2, \"never\"], // 在块级作用域外访问块内定义的变量是否报错提示 \"block-scoped-var\": 0, // if while function 后面的&#123;必须与if在同一行，java风格。 \"brace-style\": [2, \"1tbs\", &#123; \"allowSingleLine\": true &#125;], // 双峰驼命名格式 \"camelcase\": 2, // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号， // always-multiline：多行模式必须带逗号，单行模式不能带逗号 \"comma-dangle\": [2, \"never\"], // 控制逗号前后的空格 \"comma-spacing\": [2, &#123; \"before\": false, \"after\": true &#125;], // 控制逗号在行尾出现还是在行首出现 // http://eslint.org/docs/rules/comma-style \"comma-style\": [2, \"last\"], // 圈复杂度 \"complexity\": [2,9], // 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always \"computed-property-spacing\": [2,\"never\"], // 强制方法必须返回值，TypeScript强类型，不配置 \"consistent-return\": 0, // 用于指统一在回调函数中指向this的变量名，箭头函数中的this已经可以指向外层调用者，应该没卵用了 // e.g [0,\"that\"] 指定只能 var that = this. that不能指向其他任何值，this也不能赋值给that以外的其他值 \"consistent-this\": 0, // 强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示 \"constructor-super\": 0, // if else while for do后面的代码块是否需要&#123; &#125;包围，参数： // multi 只有块中有多行语句时才需要&#123; &#125;包围 // multi-line 只有块中有多行语句时才需要&#123; &#125;包围, 但是块中的执行语句只有一行时， // 块中的语句只能跟和if语句在同一行。if (foo) foo++; else doSomething(); // multi-or-nest 只有块中有多行语句时才需要&#123; &#125;包围, 如果块中的执行语句只有一行，执行语句可以零另起一行也可以跟在if语句后面 // [2, \"multi\", \"consistent\"] 保持前后语句的&#123; &#125;一致 // default: [2, \"all\"] 全都需要&#123; &#125;包围 \"curly\": [2, \"all\"], // switch语句强制default分支，也可添加 // no default 注释取消此次警告 \"default-case\": 2, // 强制object.key 中 . 的位置，参数: // property，'.'号应与属性在同一行 // object, '.' 号应与对象名在同一行 \"dot-location\": [2, \"property\"], // 强制使用.号取属性 // 参数： allowKeywords：true 使用保留字做属性名时，只能使用.方式取属性 // false 使用保留字做属性名时, 只能使用[]方式取属性 e.g [2, &#123;\"allowKeywords\": false&#125;] // allowPattern: 当属性名匹配提供的正则表达式时，允许使用[]方式取值,否则只能用.号取值 e.g [2, &#123;\"allowPattern\": \"^[a-z]+(_[a-z]+)+$\"&#125;] \"dot-notation\": [2, &#123;\"allowKeywords\": true&#125;], // 文件末尾强制换行 \"eol-last\": 2, // 使用 === 替代 == \"eqeqeq\": [2, \"allow-null\"], // 方法表达式是否需要命名 \"func-names\": 0, // 方法定义风格，参数： // declaration: 强制使用方法声明的方式，function f()&#123;&#125; e.g [2, \"declaration\"] // expression：强制使用方法表达式的方式，var f = function() &#123;&#125; e.g [2, \"expression\"] // allowArrowFunctions: declaration风格中允许箭头函数。 e.g [2, \"declaration\", &#123; \"allowArrowFunctions\": true &#125;] \"func-style\": 0, \"no-alert\": 0,//禁止使用alert confirm prompt\"no-array-constructor\": 2,//禁止使用数组构造器\"no-bitwise\": 0,//禁止使用按位运算符\"no-caller\": 1,//禁止使用arguments.caller或arguments.callee\"no-catch-shadow\": 2,//禁止catch子句参数与外部作用域变量同名\"no-class-assign\": 2,//禁止给类赋值\"no-cond-assign\": 2,//禁止在条件表达式中使用赋值语句\"no-console\": 2,//禁止使用console\"no-const-assign\": 2,//禁止修改const声明的变量\"no-constant-condition\": 2,//禁止在条件中使用常量表达式 if(true) if(1)\"no-continue\": 0,//禁止使用continue\"no-control-regex\": 2,//禁止在正则表达式中使用控制字符\"no-debugger\": 2,//禁止使用debugger\"no-delete-var\": 2,//不能对var声明的变量使用delete操作符\"no-div-regex\": 1,//不能使用看起来像除法的正则表达式/=foo/\"no-dupe-keys\": 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;\"no-dupe-args\": 2,//函数参数不能重复\"no-duplicate-case\": 2,//switch中的case标签不能重复\"no-else-return\": 2,//如果if语句里面有return,后面不能跟else语句\"no-empty\": 2,//块语句中的内容不能为空\"no-empty-character-class\": 2,//正则表达式中的[]内容不能为空\"no-empty-label\": 2,//禁止使用空label\"no-eq-null\": 2,//禁止对null使用==或!=运算符\"no-eval\": 1,//禁止使用eval\"no-ex-assign\": 2,//禁止给catch语句中的异常参数赋值\"no-extend-native\": 2,//禁止扩展native对象\"no-extra-bind\": 2,//禁止不必要的函数绑定\"no-extra-boolean-cast\": 2,//禁止不必要的bool转换\"no-extra-parens\": 2,//禁止非必要的括号\"no-extra-semi\": 2,//禁止多余的冒号\"no-fallthrough\": 1,//禁止switch穿透\"no-floating-decimal\": 2,//禁止省略浮点数中的0 .5 3.\"no-func-assign\": 2,//禁止重复的函数声明\"no-implicit-coercion\": 1,//禁止隐式转换\"no-implied-eval\": 2,//禁止使用隐式eval\"no-inline-comments\": 0,//禁止行内备注\"no-inner-declarations\": [2, \"functions\"],//禁止在块语句中使用声明（变量或函数）\"no-invalid-regexp\": 2,//禁止无效的正则表达式\"no-invalid-this\": 2,//禁止无效的this，只能用在构造器，类，对象字面量\"no-irregular-whitespace\": 2,//不能有不规则的空格\"no-iterator\": 2,//禁止使用__iterator__ 属性\"no-label-var\": 2,//label名不能与var声明的变量名相同\"no-labels\": 2,//禁止标签声明\"no-lone-blocks\": 2,//禁止不必要的嵌套块\"no-lonely-if\": 2,//禁止else语句内只有if语句\"no-loop-func\": 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）\"no-mixed-requires\": [0, false],//声明时不能混用声明类型\"no-mixed-spaces-and-tabs\": [2, false],//禁止混用tab和空格\"linebreak-style\": [0, \"windows\"],//换行风格\"no-multi-spaces\": 1,//不能用多余的空格\"no-multi-str\": 2,//字符串不能用\\换行\"no-multiple-empty-lines\": [1, &#123;\"max\": 2&#125;],//空行最多不能超过2行\"no-native-reassign\": 2,//不能重写native对象\"no-negated-in-lhs\": 2,//in 操作符的左边不能有!\"no-nested-ternary\": 0,//禁止使用嵌套的三目运算\"no-new\": 1,//禁止在使用new构造一个实例后不赋值\"no-new-func\": 1,//禁止使用new Function\"no-new-object\": 2,//禁止使用new Object()\"no-new-require\": 2,//禁止使用new require\"no-new-wrappers\": 2,//禁止使用new创建包装实例，new String new Boolean new Number\"no-obj-calls\": 2,//不能调用内置的全局对象，比如Math() JSON()\"no-octal\": 2,//禁止使用八进制数字\"no-octal-escape\": 2,//禁止使用八进制转义序列\"no-param-reassign\": 2,//禁止给参数重新赋值\"no-path-concat\": 0,//node中不能使用__dirname或__filename做路径拼接\"no-plusplus\": 0,//禁止使用++，--\"no-process-env\": 0,//禁止使用process.env\"no-process-exit\": 0,//禁止使用process.exit()\"no-proto\": 2,//禁止使用__proto__属性\"no-redeclare\": 2,//禁止重复声明变量\"no-regex-spaces\": 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/\"no-restricted-modules\": 0,//如果禁用了指定模块，使用就会报错\"no-return-assign\": 1,//return 语句中不能有赋值表达式\"no-script-url\": 0,//禁止使用javascript:void(0)\"no-self-compare\": 2,//不能比较自身\"no-sequences\": 0,//禁止使用逗号运算符\"no-shadow\": 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名\"no-shadow-restricted-names\": 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用\"no-spaced-func\": 2,//函数调用时 函数名与()之间不能有空格\"no-sparse-arrays\": 2,//禁止稀疏数组， [1,,2]\"no-sync\": 0,//nodejs 禁止同步方法\"no-ternary\": 0,//禁止使用三目运算符\"no-trailing-spaces\": 1,//一行结束后面不要有空格\"no-this-before-super\": 0,//在调用super()之前不能使用this或super\"no-throw-literal\": 2,//禁止抛出字面量错误 throw \"error\";\"no-undef\": 1,//不能有未定义的变量\"no-undef-init\": 2,//变量初始化时不能直接给它赋值为undefined\"no-undefined\": 2,//不能使用undefined\"no-unexpected-multiline\": 2,//避免多行表达式\"no-underscore-dangle\": 1,//标识符不能以_开头或结尾\"no-unneeded-ternary\": 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;\"no-unreachable\": 2,//不能有无法执行的代码\"no-unused-expressions\": 2,//禁止无用的表达式\"no-unused-vars\": [2, &#123;\"vars\": \"all\", \"args\": \"after-used\"&#125;],//不能有声明后未被使用的变量或参数\"no-use-before-define\": 2,//未定义前不能使用\"no-useless-call\": 2,//禁止不必要的call和apply\"no-void\": 2,//禁用void操作符\"no-var\": 0,//禁用var，用let和const代替\"no-warning-comments\": [1, &#123; \"terms\": [\"todo\", \"fixme\", \"xxx\"], \"location\": \"start\" &#125;],//不能有警告备注\"no-with\": 2,//禁用with\"array-bracket-spacing\": [2, \"never\"],//是否允许非空数组里面有多余的空格\"arrow-parens\": 0,//箭头函数用小括号括起来\"arrow-spacing\": 0,//=&gt;的前/后括号\"accessor-pairs\": 0,//在对象中使用getter/setter\"block-scoped-var\": 0,//块语句中使用var\"brace-style\": [1, \"1tbs\"],//大括号风格\"callback-return\": 1,//避免多次调用回调什么的\"camelcase\": 2,//强制驼峰法命名\"comma-dangle\": [2, \"never\"],//对象字面量项尾不能有逗号\"comma-spacing\": 0,//逗号前后的空格\"comma-style\": [2, \"last\"],//逗号风格，换行时在行首还是行尾\"complexity\": [0, 11],//循环复杂度\"computed-property-spacing\": [0, \"never\"],//是否允许计算后的键名什么的\"consistent-return\": 0,//return 后面是否允许省略\"consistent-this\": [2, \"that\"],//this别名\"constructor-super\": 0,//非派生类不能调用super，派生类必须调用super\"curly\": [2, \"all\"],//必须使用 if()&#123;&#125; 中的&#123;&#125;\"default-case\": 2,//switch语句最后必须有default\"dot-location\": 0,//对象访问符的位置，换行的时候在行首还是行尾\"dot-notation\": [0, &#123; \"allowKeywords\": true &#125;],//避免不必要的方括号\"eol-last\": 0,//文件以单一的换行符结束\"eqeqeq\": 2,//必须使用全等\"func-names\": 0,//函数表达式必须有名字\"func-style\": [0, \"declaration\"],//函数风格，规定只能使用函数声明/函数表达式\"generator-star-spacing\": 0,//生成器函数*的前后空格\"guard-for-in\": 0,//for in循环要用if语句过滤\"handle-callback-err\": 0,//nodejs 处理错误\"id-length\": 0,//变量名长度\"indent\": [2, 4],//缩进风格\"init-declarations\": 0,//声明时必须赋初值\"key-spacing\": [0, &#123; \"beforeColon\": false, \"afterColon\": true &#125;],//对象字面量中冒号的前后空格\"lines-around-comment\": 0,//行前/行后备注\"max-depth\": [0, 4],//嵌套块深度\"max-len\": [0, 80, 4],//字符串最大长度\"max-nested-callbacks\": [0, 2],//回调嵌套深度\"max-params\": [0, 3],//函数最多只能有3个参数\"max-statements\": [0, 10],//函数内最多有几个声明\"new-cap\": 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用\"new-parens\": 2,//new时必须加小括号\"newline-after-var\": 2,//变量声明后是否需要空一行\"object-curly-spacing\": [0, \"never\"],//大括号内是否允许不必要的空格\"object-shorthand\": 0,//强制对象字面量缩写语法\"one-var\": 1,//连续声明\"operator-assignment\": [0, \"always\"],//赋值运算符 += -=什么的\"operator-linebreak\": [2, \"after\"],//换行时运算符在行尾还是行首\"padded-blocks\": 0,//块语句内行首行尾是否要空行\"prefer-const\": 0,//首选const\"prefer-spread\": 0,//首选展开运算\"prefer-reflect\": 0,//首选Reflect的方法\"quotes\": [1, \"single\"],//引号类型 `` \"\" ''\"quote-props\":[2, \"always\"],//对象字面量中的属性名是否强制双引号\"radix\": 2,//parseInt必须指定第二个参数\"id-match\": 0,//命名检测\"require-yield\": 0,//生成器函数必须有yield\"semi\": [2, \"always\"],//语句强制分号结尾\"semi-spacing\": [0, &#123;\"before\": false, \"after\": true&#125;],//分号前后空格\"sort-vars\": 0,//变量声明时排序\"space-after-keywords\": [0, \"always\"],//关键字后面是否要空一格\"space-before-blocks\": [0, \"always\"],//不以新行开始的块&#123;前面要不要有空格\"space-before-function-paren\": [0, \"always\"],//函数定义时括号前面要不要有空格\"space-in-parens\": [0, \"never\"],//小括号里面要不要有空格\"space-infix-ops\": 0,//中缀操作符周围要不要有空格\"space-return-throw-case\": 2,//return throw case后面要不要加空格\"space-unary-ops\": [0, &#123; \"words\": true, \"nonwords\": false &#125;],//一元运算符的前/后要不要加空格\"spaced-comment\": 0,//注释风格不要有空格什么的\"strict\": 2,//使用严格模式\"use-isnan\": 2,//禁止比较时使用NaN，只能用isNaN()\"valid-jsdoc\": 0,//jsdoc规则\"valid-typeof\": 2,//必须使用合法的typeof的值\"vars-on-top\": 2,//var必须放在作用域顶部\"wrap-iife\": [2, \"inside\"],//立即执行函数表达式的小括号风格\"wrap-regex\": 0,//正则表达式字面量用小括号包起来\"yoda\": [2, \"never\"]//禁止尤达条件 &#125; &#125; 参考文章：ESLint配置参数介绍关于eslint使用规则，和各种报错应对书写规则。 vue2.0","categories":[{"name":"eslint","slug":"eslint","permalink":"http://yoursite.com/categories/eslint/"}],"tags":[{"name":"Vuejs","slug":"Vuejs","permalink":"http://yoursite.com/tags/Vuejs/"},{"name":"eslint","slug":"eslint","permalink":"http://yoursite.com/tags/eslint/"},{"name":"前端规范工具","slug":"前端规范工具","permalink":"http://yoursite.com/tags/前端规范工具/"}]},{"title":"Vue(Vue综合实战项目)","slug":"Vue之入门综合项目实战","date":"2017-06-25T05:17:02.000Z","updated":"2017-06-25T09:19:36.000Z","comments":true,"path":"2017/06/25/Vue之入门综合项目实战/","link":"","permalink":"http://yoursite.com/2017/06/25/Vue之入门综合项目实战/","excerpt":"","text":"正文开始Vue综合实战项目 Vue综合实战项目前置知识学习 npm 学习 官方文档 推荐资料 npm入门 npm介绍 需要了解的知识点 package.json 文件相关配置选项 npm 本地安装、全局安装、本地开发安装等区别及相关命令 npm script脚步的基本编写能力 有时间专门写一个这样的专题，如果需要可以邮件我。modifywyx@gmail.com webpack基础学习 官方文档 Webpack了解的知识点： webpack的基本配置 了解webpack常用的loader： less-loader、sass-loader、 vue-loader、style-loader、css-loader、eslint-loader、babel-loader等 熟悉Webpack的webpack-dev-server的基本配置和使用，会配置热更新 es6语法学习 阮一峰老师的大作《ECMAScript 6 入门》 需要学习的知识点 es6的模块机制 各种最新语法糖，简写、geter、setter、箭头函数 类、继承的心机制… nodejs基础知识 知识点学习： 文件操作 http服务 express 组件化开发思想 Vue脚手架工具：vue-cli构建实战项目其实如果编写Vue的前端项目，直接使用vue的官方vue-cli构建工具最好用，一个命令就可以直接生成项目的结构和目录。而且官方需要依赖的包也可以自动配置好，只需要npm instal一下，然后就可以开发测试了。 vue-cli安装1234567# 安装vue-cli。 安装之前首先确保你已经安装好了nodejs 而且打开命令行$ npm install -g vue-cli# 校验一下是否安装成功$ vue -V#=&gt; 2.5.1 我当前的版本是这个，你的可能比这个新 使用vue-cli初始化项目通过以下命令的方式可以创建一个项目文件夹，并初始化对应的文件。 1$ vue init &lt;template-name&gt; &lt;project-name&gt; 其中template-name可以取以下值，每个值对应不同的项目构建的模板。 webpack–全功能的Webpack + vueify，包括热加载，静态检测，单元测试 webpack-simple–一个简易的Webpack + vueify，以便于快速开始。 browserify–全功能的Browserify + vueify，包括热加载，静态检测，单元测试 browserify-simple–一个简易的Browserify + vueify，以便于快速开始。 安装和开发控制台的命令： 1234567891011121314# 如果已经安装，请省略$ npm install -g vue-cli# 初始化一个webpack全功能包的vue项目，请您把my-project换成你自己的项目名。$ vue init webpack my-project# 用命令行进入当前项目目录$ cd my-project# npm安装所有的依赖的包$ npm install# 运行测试的首页$ npm run dev 综合实例开发记录 通过vue-cli构建工具初始化项目目录 安装过程，控制台会问你项目名称是什么？项目描述？项目作者，是否使用eslint校验，是否使用单元测试等…. 我的安装过程如下请参考： 1234567891011121314151617181920212223242526272829$ vue init webpack ttl # =&gt; 安装webpack模板的项目 ttl（项目名可以随便取） A newer version of vue-cli is available. latest: 2.6.0 installed: 2.5.1 This will install Vue 2.x version of template. For Vue 1.x use: vue init webpack#1.0 ttl? Project name mydemovue # =&gt; 项目名称? Project description A Vue.js project # =&gt; 项目描述? Author malun &lt;malun666@126.com&gt; # =&gt; 作者? Vue build standalone # =&gt; 是否支持单文件组件? Use ESLint to lint your code? Yes # =&gt; 是否支持ESLint代码校验? Pick an ESLint preset Standard # =&gt; 校验的标准是什么？? Setup unit tests with Karma + Mocha? Yes # =&gt; 是否使用单元测试? Setup e2e tests with Nightwatch? Yes # =&gt; 是否使用e2e测试 vue-cli · Generated \"ttl\". To get started: cd ttl npm install npm run dev Documentation can be found at https://vuejs-templates.github.io/webpack 通过上面一系列的命令后，我们就会创建一个webpack配置好的项目包。目录结构如下： 1234567891011121314ttl|--.babelrc #=&gt; babel的配置文件，主要用于转换es6等最新的js语法。|--.editorconfig #=&gt; 编辑器配置|--.eslintignore #=&gt; eslint的忽略校验的配置文件|--.eslintrc.js #=&gt; eslint的配置校验js是否规范的配置文件|--.gitignore #=&gt; 设置git忽略的管理的文件|--README.md #=&gt; readme说明文件|--build/ #=&gt; 自动构建存放的文件地方|--config/ #=&gt; 当前开发、测试等配置的文件，需要懂点nodejs了啊。|--index.html #=&gt; 项目的主入口的模板|--package.json #=&gt; npm的配置文件|--src/ #=&gt; 源码目录|--static/ #=&gt; 静态资源存放的目录|--test/ #=&gt; 测试相关目录 初始化依赖包 12345$ cd ttl #=&gt; 进入上面创建好的项目目录$ npm install #=&gt; 安装所有的依赖包。 安装过程可能非常长，网络也可能有问题，请耐心等待。# 安装完成后，可以直接运行测试,如果自动打开浏览器，并跳转到http://localhost:8080/ 说明一切都ok了。$ npm run dev npm 安装的时候经常网会断开，国内的网（哎，说多了都是泪）你懂的。最好能科学上网，或者是用淘宝的npm的镜像 安装vue-router组件 1$ npm i -S vue-router 到项目的 /src/components/ 目录下创建三个组件文件。 分别是： 首页组件 12345678910111213141516171819202122&lt;template&gt; &lt;div class=\"home\"&gt; &lt;h3&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'home', // 组件可以有自己的名字。 data () &#123; // 组件的data必须是函数 return &#123; msg: '这里是Home视图' &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;h3 &#123; background-color: #82c;&#125;&lt;/style&gt; 用户首页组件 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;h3&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; // es6的模块导出定义语法，此模块导出默认的对象 name: 'user', // 组件可以有自己的名字。 data () &#123; // 组件的data必须是函数 return &#123; msg: '这里是User视图' &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;h3 &#123; background-color: red;&#125;&lt;/style&gt; 产品组件 12345678910111213141516171819202122&lt;template&gt; &lt;div class=\"product\"&gt; &lt;h3&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'product', // 组件可以有自己的名字。 data () &#123; // 组件的data必须是函数 return &#123; msg: '这里是Home视图' &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;h3 &#123; background-color: green;&#125;&lt;/style&gt; 项目的目录结构为： 123456ttl|-- src|--|-- Hello.vue|--|-- Home.vue|--|-- Product.vue|--|-- User.vue 创建router对象及配置路由 在src目录下创建approuter.js文件。然后添加如下代码： 123456789101112import VueRouter from 'vue-router' // 导入路由模块import Home from './components/Home.vue' // 导入Home组件import User from './components/User.vue'import Product from './components/Product.vue'export default new VueRouter(&#123; // 定义路由规则对象 routes: [ &#123;path: '/home', component: Home&#125;, &#123;path: '/user/:id', component: User&#125;, &#123;path: '/product/:id', component: Product&#125; ]&#125;) 修改main.js文件找到src/目录下的main.js文件，共修改4处，添加路由引用、添加路由规则对象导入、启用路由、将路由键入到Vue中。修改此文件为： 1234567891011121314151617// The Vue build version to load with the `import` command// (runtime-only or standalone) has been set in webpack.base.conf with an alias.import Vue from 'vue'import App from './App'import VueRouter from 'vue-router' // +++1、导入路由组件import router from './approuter' // +++2、导入我们自己写的路由配置文件// +++ 3、使用路由组件Vue.use(VueRouter)/* eslint-disable no-new */new Vue(&#123; el: '#app', template: '&lt;App/&gt;', components: &#123; App &#125;, router: router // +++4、添加路由对象&#125;) 在app.vue中添加路由导航 最终代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div id=\"app\"&gt; &lt;nav class=\"top-menu\"&gt; &lt;ul &gt; &lt;li v-for=\"item in menuList\"&gt; &lt;router-link :to=\"item.url\"&gt;&#123;&#123; item.name &#125;&#125;&lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;hr&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'app', data: function () &#123; return &#123; menuList: [ &#123; name: '首页', url: '/home' &#125;, &#123; name: '用户', url: '/user/19' &#125;, &#123; name: '产品', url: '/product/20' &#125; ] &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123;&#125;.top-menu ul, .top-menu li &#123; list-style: none;&#125;.top-menu &#123; overflow: hidden;&#125;.top-menu li &#123; float: left; width: 100px;&#125;&lt;/style&gt; 刷新一下浏览器，你将会看到最终的运行结果。 总结Vue的入门系列基本都写完了，大部分内容是参考了官网的文档。 还有很多内容没有整理到这个系列中。比如：vue的过渡动画，vue的异步刷新队列，vue的过滤器等，我相信你通过本文档就能实现vue的入门了，那些琐碎的知识点只要看一下官方的文档应该很容入门。 这一次整理过程，让我对Vue有了更深入的认识，之前不熟悉的东西，强迫自己把文档写一遍后，认识比以前更清晰了。Vue确实带来很多的惊喜。希望这个文档对你有用。","categories":[{"name":"VueJS","slug":"VueJS","permalink":"http://yoursite.com/categories/VueJS/"}],"tags":[{"name":"Vuejs","slug":"Vuejs","permalink":"http://yoursite.com/tags/Vuejs/"},{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"},{"name":"Vue综合实战项目","slug":"Vue综合实战项目","permalink":"http://yoursite.com/tags/Vue综合实战项目/"}]},{"title":"Vue入门之Vuex实战","slug":"vue入门之vuex实战","date":"2017-06-25T05:17:02.000Z","updated":"2017-06-26T12:20:12.000Z","comments":true,"path":"2017/06/25/vue入门之vuex实战/","link":"","permalink":"http://yoursite.com/2017/06/25/vue入门之vuex实战/","excerpt":"","text":"正文开始Vue入门之Vuex实战 Vue入门之Vuex实战引言Vue组件化做的确实非常彻底，它独有的vue单文件组件也是做的非常有特色。组件化的同时带来的是：组件之间的数据共享和通信的难题。尤其Vue组件设计的就是，父组件通过子组件的prop进行传递数据，而且数据传递是单向的。也就是说：父组件可以把数据传递给子组件，但是反之则不同。如下图所示： 单向数据流动单方向的数据流动带来了非常简洁和清晰的数据流，纯展示性或者独立性较强的模块的开发确实非常方便和省事。但是复杂的页面逻辑，组件之间的数据共享处理就会需要通过事件总线的方式解决或者使用Vue的Vuex框架了。 子组件通知父组件数据更新：事件方式的实现子组件可以在子组件内触发事件，然后在父容器中添加子组件时绑定父容器的方法为事件响应方法的方式.如下图所示： 使用 v-on 绑定自定义事件 123每个 Vue 实例都实现了事件接口(Events interface)，即：使用 $on(eventName) 监听事件使用 $emit(eventName) 触发事件 参考代码案例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue入门之event message&lt;/title&gt; &lt;!-- 新 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel=\"stylesheet\" href=\"http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css\"&gt; &lt;!-- 可选的Bootstrap主题文件（一般不用引入） --&gt; &lt;link rel=\"stylesheet\" href=\"http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap-theme.min.css\"&gt; &lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt; &lt;script src=\"http://cdn.bootcss.com/jquery/1.11.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt; &lt;script src=\"http://cdn.bootcss.com/bootstrap/3.3.0/js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;推荐次数：&#123;&#123; voteCount &#125;&#125;&lt;/p&gt; &lt;hr&gt; &lt;!--绑定两个自定义事件，当组件内部触发了事件后，会自定调用父容器绑定的methods的方法，达到了子容器向父容器数据进行通信同步的方法--&gt; &lt;vote-btn v-on:vote=\"voteAction\" v-on:sendmsg=\"sendMsgAction\"&gt;&lt;/vote-btn&gt; &lt;hr&gt; &lt;ul class=\"list-group\"&gt; &lt;li v-for=\"o in msg\" class=\"list-group-item\"&gt;&#123;&#123;o&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; Vue.component('vote-btn', &#123; template: ` &lt;div&gt; &lt;button class=\"btn btn-success\" v-on:click=\"voteArticle\"&gt;推荐&lt;/button&gt; &lt;hr/&gt; &lt;input type=\"text\" v-model=\"txtMsg\" /&gt; &lt;button v-on:click=\"sendMsg\" class=\"btn btn-success\"&gt;发送消息&lt;/button&gt; &lt;/div&gt; `, data: function () &#123; return &#123; txtMsg: \"\" &#125; &#125;, methods: &#123; voteArticle: function () &#123; // 触发事件，vote this.$emit('vote') &#125;, sendMsg: function () &#123; // 触发事件，sendmsg，并 this.$emit('sendmsg', this.txtMsg) &#125; &#125; &#125;) var app = new Vue(&#123; el: '#app', data: &#123; voteCount: 0, msg: [] &#125;, methods: &#123; voteAction: function() &#123; // 事件触发后，会直接执行此方法 this.voteCount += 1 &#125;, sendMsgAction: function (item) &#123; this.msg.push(item) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件总线方式解决非父子组件数据同步如果非父子组件怎么通过事件进行同步数据，或者同步消息呢？Vue中的事件触发和监听都是跟一个具体的Vue实例挂钩。所以在不同的Vue实例中想进行事件的统一跟踪和触发，那就需要一个公共的Vue实例，这个实例就是公共的事件对象。 参考下面做的一个购物车的案例的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue入门之event message&lt;/title&gt; &lt;!-- 新 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel=\"stylesheet\" href=\"http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css\"&gt; &lt;!-- 可选的Bootstrap主题文件（一般不用引入） --&gt; &lt;link rel=\"stylesheet\" href=\"http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap-theme.min.css\"&gt; &lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt; &lt;script src=\"http://cdn.bootcss.com/jquery/1.11.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt; &lt;script src=\"http://cdn.bootcss.com/bootstrap/3.3.0/js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;product-list :products=\"products\" v-on:addpro=\"addToCarts\"&gt; &lt;/product-list&gt; &lt;hr&gt; &lt;cart :cart-products=\"carts\"&gt; &lt;/cart&gt; &lt;/div&gt; &lt;script&gt; var eventBus = new Vue() Vue.component('cart', &#123; template: ` &lt;table class=\"table table-borderd table-striped table-hover\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;商品编号&lt;/th&gt; &lt;th&gt;商品名&lt;/th&gt; &lt;th&gt;数量&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=\"item in cartProducts\"&gt; &lt;td&gt;&#123;&#123; item.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt; &lt;td&gt; &#123;&#123; item.count &#125;&#125; &lt;/td&gt; &lt;td&gt; &lt;button type=\"button\" @click=\"removeCarts(item)\" class=\"btn btn-success\"&gt;&lt;i class=\"glyphicon glyphicon-remove\"&gt;&lt;/i&gt;&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; `, data: function () &#123; return &#123; &#125; &#125;, methods: &#123; removeCarts: function (item) &#123; eventBus.$emit('remo', item) &#125; &#125;, props: ['cartProducts'] &#125;) Vue.component('product-list', &#123; template: ` &lt;table class=\"table table-borderd table-striped table-hover\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;商品编号&lt;/th&gt; &lt;th&gt;商品名&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=\"item in products\"&gt; &lt;td&gt;&#123;&#123; item.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;button type=\"button\" v-on:click=\"addToCarts(item)\" class=\"btn btn-success\"&gt;&lt;i class=\"glyphicon glyphicon-shopping-cart\"&gt;&lt;/i&gt;&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; `, data: function () &#123; return &#123; &#125; &#125;, methods: &#123; addToCarts: function (item) &#123; this.$emit('addpro', item) &#125; &#125;, props: ['products'], &#125;) var app = new Vue(&#123; el: '#app', data: &#123; products: [ &#123; id: '1', name: '鳄鱼' &#125;, &#123; id: '2', name: '蛇' &#125;, &#123; id: '3', name: '兔子' &#125;, &#123; id: '4', name: '驴' &#125;, &#123; id: '5', name: '孔雀' &#125; ], carts: [] &#125;, methods: &#123; addToCarts: function (item) &#123; var isExist = false for(var i=0; i&lt;this.carts.length; i++) &#123; if( item.id === this.carts[i].id ) &#123; item.count = this.carts[i].count + 1 Vue.set(this.carts, i, item) isExist = true &#125; &#125; !isExist &amp;&amp; (item.count = 1, this.carts.push(item)) &#125;, removeCarts: function (item) &#123; for(var i =0; i&lt;this.carts.length; i++) &#123; if( item.id === this.carts[i].id) &#123; this.carts.splice(i,1) &#125; &#125; &#125; &#125;, mounted: function () &#123; self = this; eventBus.$on('remo', function (item) &#123; self.removeCarts(item) &#125;) &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vuex解决复杂单页面应用上面的方式只能解决一些简单的页面中的组件的通信问题，但是如果是复杂的单页面应用就需要使用更强大的Vuex来帮我们进行状态的统一管理和同步。 当第一次接触Vuex的时候，眼前一亮，之前经过Redux之后，被它繁琐的使用令我痛苦不已，虽然思路很清晰，其实完全可以设计的更简单和高效。当我接触到Vuex之后，发现这就是我想要的。的确简洁就是一种艺术。 其实本质上，Vuex就是一个大的EventBus对象的升级版本，相当于一个特定的仓库，所有数据都在统一的仓库中，进行统一的管理。 几个核心的概念： State： Vuex仓库中的数据。 Getter： 类似于Vue实例中的计算属性，Getter就是普通的获取state包装函数。 Mutations: Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutations 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。 Action: action可以触发Mutations，不能直接改变state。 看下面一张图了解一下Vuex整体的数据流动： Vuex实例demo可能前面的图和概念都太多了，先看一个例子，简单了解一下Vuex中的仓库的数据 怎么整合到 Vue的实例中去。 创建Vuexdemo的项目 123456789101112# 通过vue-cli创建vuexdemo的项目，注意首先cd到你的存放项目代码的目录vue init webpack vuexdemo# 过程中，会有几个选项你可以选择输入Y或者n来开启或者关闭某些选项。# 创建完成后，就可以通过以下命令，进行初始化和安装相关的依赖项了。cd vuexdemonpm installnpm run dev# 然后安装 vuexnpm i vuex -S","categories":[{"name":"VueJS","slug":"VueJS","permalink":"http://yoursite.com/categories/VueJS/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yoursite.com/tags/angularjs/"},{"name":"Vue组件间通信","slug":"Vue组件间通信","permalink":"http://yoursite.com/tags/Vue组件间通信/"}]},{"title":"Vue(Vue入门之路由详解)","slug":"vue入门之路由","date":"2017-06-25T05:17:02.000Z","updated":"2017-06-25T09:06:14.000Z","comments":true,"path":"2017/06/25/vue入门之路由/","link":"","permalink":"http://yoursite.com/2017/06/25/vue入门之路由/","excerpt":"","text":"正文开始Vue入门之路由详解 Vue路由详解 对于前端来说，其实浏览器配合超级连接就很好的实现了路由功能。但是对于单页面应用来说，浏览器和超级连接的跳转方式已经不能适用，所以各大框架纷纷给出了单页面应用的解决路由跳转的方案。 Vue框架的兼容性非常好，可以很好的跟其他第三方的路由框架进行结合。当然官方也给出了路由的方案： vue-router;建议还是用官方的最好，使用量也是最大，相对来说Vue框架的升级路由组件升级也会及时跟上，所以为了以后的维护和升级方便还是使用Vue自家的东西最好。 Vue-router的版本对应 注意: vue-router@2.x 只适用于 Vue 2.x 版本。vue-router@1.x 对应于Vue1.x版本。 的Github地址：vue-router 文档地址 vue-router的安装使用 CDN连接方式 https://unpkg.com/vue-router/dist/vue-router.js npm 安装 1npm install vue-router vue-router 入门demovue-router开发的步骤： 第一步： 引入vue和vue-router包。 可以使用cdn的方式或者npm的方式。如果配合npm和webpack的话可以直接作为一个模块导入即可。但是作为初学入门的话建议还是直接使用cdn包的形式，先学会怎么用路由。 12&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"&gt;&lt;/script&gt; 第二步： 定义路由跳转的组件 123// 1. 定义（路由）组件。const Foo = &#123; template: '&lt;div&gt;foo&lt;/div&gt;' &#125;const Bar = &#123; template: '&lt;div&gt;bar&lt;/div&gt;' &#125; 第三步： 定义路由规则对象 123456789101112// 每个路由path应该映射一个组件。 其中\"component\" 可以是// 通过 Vue.extend() 创建的组件构造器，// 或者，只是一个组件配置对象。const routes = [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125;]// 创建路由对象const router = new VueRouter(&#123; routes // （缩写）相当于 routes: routes，es6的新语法&#125;) 第四步： 创建Vue对象，并加重上面创建的路由对象 12345// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能const app = new Vue(&#123; router&#125;).$mount('#app') 第五步： 在模板中编写路由跳转链接 12345678910111213&lt;div id=\"app\"&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to=\"/foo\"&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to=\"/bar\"&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 最终的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"&gt;&lt;/script&gt;&lt;div id=\"app\"&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to=\"/foo\"&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to=\"/bar\"&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt;// 1. 定义（路由）组件。// 可以从其他文件 import 进来const Foo = &#123; template: '&lt;div&gt;foo&lt;/div&gt;' &#125;const Bar = &#123; template: '&lt;div&gt;bar&lt;/div&gt;' &#125;// 2. 定义路由const routes = [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125;]// 3. 创建 router 实例，然后传 `routes` 配置// 你还可以传别的配置参数, 不过先这么简单着吧。const router = new VueRouter(&#123; routes // （缩写）相当于 routes: routes&#125;)// 4. 创建和挂载根实例。// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能const app = new Vue(&#123; router&#125;).$mount('#app')&lt;/script&gt; 使用vue-router的综合实例下面是一个综合的例子, 页面上有几个导航的按钮，然后通过点击不同的按钮，可以在当前页面切换不同的组件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue入门之extend全局方法&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"&gt;&lt;/script&gt; &lt;style&gt; ul, li &#123; list-style: none; &#125; ul &#123; overflow: hidden; &#125; li &#123; float: left; width: 100px; &#125; h2 &#123; background-color: #903;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;top-bar&gt; &lt;/top-bar&gt; &lt;hr&gt; &lt;p&gt;email to: &#123;&#123; email &#125;&#125;&lt;/p&gt; &lt;hr&gt; &lt;router-view class=\"view one\"&gt;&lt;/router-view&gt; &lt;footer-bar&gt;&lt;/footer-bar&gt; &lt;/div&gt; &lt;script&gt; var topbarTemp = ` &lt;nav&gt; &lt;ul&gt; &lt;li v-for=\"item in NavList\"&gt; &lt;router-link :to=\"item.url\"&gt;&#123;&#123; item.name &#125;&#125;&lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; `; // 定义组件：topbar Vue.component('top-bar', &#123; template: topbarTemp, data: function () &#123; return &#123; NavList: [ &#123; name: '首页', url: '/home'&#125;, &#123; name: '产品', url: '/product'&#125;, &#123; name: '服务', url: '/service'&#125;, &#123; name: '关于', url: '/about'&#125; ] &#125; &#125; &#125;); Vue.component('footer-bar', &#123; // 定义组件 footerbar template: ` &lt;footer&gt; &lt;hr/&gt; &lt;p&gt;版权所有@flydragon&lt;p&gt; &lt;/footer&gt; ` &#125;); // 创建home模块 var home = &#123; template: `&lt;div&gt; &lt;h2&gt;&#123;&#123; msg &#125;&#125;&lt;h2&gt;&lt;/div&gt;`, data: function () &#123; return &#123; msg: 'this is home view' &#125; &#125; &#125;; // 创建product 模块 var product = &#123; template: `&lt;div&gt; &#123;&#123; msg &#125;&#125;&lt;/div&gt;`, data: function () &#123; return &#123; msg: 'this is product view' &#125; &#125; &#125; // 定义路由对象 var router = new VueRouter(&#123; routes: [ &#123; path: '/home', component: home &#125;, &#123; path: '/product', component: product &#125; ] &#125;); // 初始化一个Vue实例 var app = new Vue(&#123; el: '#app', data: &#123; email: 'flydragon@gmail.com' &#125;, router: router &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 路由参数获取定义路由路径的时候，可以指定参数。参数需要通过路径进行标识：/user/:id就是定义了一个规则，/user开头，然后后面的就是id参数的值。比如：1234路由规则： /user/:id/user/9 =&gt; id = 9/user/8 =&gt; id = 8/user/1 =&gt; id = 1 然后在跳转后的vue中可以通过this.$route.params.参数名获取对应的参数。比如代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue入门之extend全局方法&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;nav&gt; &lt;router-link to=\"/user/9\"&gt;用户&lt;/router-link&gt; &lt;router-link to=\"/stu/malun\"&gt;学生&lt;/router-link&gt; &lt;hr&gt; &lt;/nav&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var user = &#123; template: ` &lt;div&gt;user id is : &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt; ` &#125;; var stu = &#123; template: ` &lt;div&gt; &lt;h2&gt;&#123;&#123; getName &#125;&#125;&lt;/h2&gt; &lt;/div&gt; `, computed: &#123; getName: function () &#123; return this.$route.params.name; &#125; &#125; &#125;; var router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: user &#125;, &#123; path: '/stu/:name', component: stu &#125; ] &#125;); var app = new Vue(&#123; el: '#app', router: router &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; js控制路由跳转上面我们演示的都是通过router-link进行跳转。 其实我们还可以通过js编程的方式进行路由的跳转。 1234567891011// 当前路由的view跳转到 /homerouter.push('home')// 对象, 跳转到/homerouter.push(&#123; path: 'home' &#125;)// 命名的路由router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;) 嵌套路由嵌套路由跟普通路由基本没有什么区别。但是可以让vue开发变的非常灵活。官网这块写的也非常好，我就直接拷贝了（原谅我吧。）实际生活中的应用界面，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件，例如：123456789/user/foo/profile /user/foo/posts+------------------+ +-----------------+| User | | User || +--------------+ | | +-------------+ || | Profile | | +------------&gt; | | Posts | || | | | | | | || +--------------+ | | +-------------+ |+------------------+ +-----------------+借助 vue-router，使用嵌套路由配置，就可以很简单地表达这种关系。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;div id=\"app\"&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;const User = &#123; template: '&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'&#125;const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User &#125; ]&#125;)这里的 &lt;router-view&gt; 是最顶层的出口，渲染最高级路由匹配到的组件。同样地，一个被渲染组件同样可以包含自己的嵌套 &lt;router-view&gt;。例如，在 User 组件的模板添加一个 &lt;router-view&gt;：const User = &#123; template: ` &lt;div class=\"user\"&gt; &lt;h2&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/h2&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; `&#125;要在嵌套的出口中渲染组件，需要在 VueRouter 的参数中使用 children 配置：const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User, children: [ &#123; // 当 /user/:id/profile 匹配成功， // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中 path: 'profile', component: UserProfile &#125;, &#123; // 当 /user/:id/posts 匹配成功 // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中 path: 'posts', component: UserPosts &#125; ] &#125; ]&#125;) 要注意，以 / 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。你会发现，children 配置就是像 routes 配置一样的路由配置数组，所以呢，你可以嵌套多层路由。 此时，基于上面的配置，当你访问 /user/foo 时，User 的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个 空的 子路由： 1234567891011121314const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User, children: [ // 当 /user/:id 匹配成功， // UserHome 会被渲染在 User 的 &lt;router-view&gt; 中 &#123; path: '', component: UserHome &#125;, // ...其他子路由 ] &#125; ]&#125;) 总结其实作为入门的话，暂时先掌握这些知识，后续","categories":[{"name":"VueJS","slug":"VueJS","permalink":"http://yoursite.com/categories/VueJS/"}],"tags":[{"name":"Vuejs","slug":"Vuejs","permalink":"http://yoursite.com/tags/Vuejs/"},{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"},{"name":"Vue路由","slug":"Vue路由","permalink":"http://yoursite.com/tags/Vue路由/"}]},{"title":"Vue(Vue列表渲染及条件渲染实战)","slug":"vue入门之列表渲染","date":"2017-06-24T05:17:02.000Z","updated":"2017-06-24T02:47:14.000Z","comments":true,"path":"2017/06/24/vue入门之列表渲染/","link":"","permalink":"http://yoursite.com/2017/06/24/vue入门之列表渲染/","excerpt":"","text":"正文开始Vue列表渲染及条件渲染实战 Vue列表渲染及条件渲染实战条件渲染有时候我们要根据数据的情况，决定标签是否进行显示或者有其他动作。最常见的就是，表格渲染的时候，如果表格没有数据，就显示无数据。如果有数据就显示表格数据。Vue帮我们提供了一个v-if的指令，帮助我们完成判断的模板处理。 1234567891011121314&lt;div id=\"app\"&gt; &lt;h1 v-if=\"ok\"&gt;Yes&lt;/h1&gt; &lt;h1 v-else&gt;No&lt;/h1&gt;&lt;/div&gt;&lt;!-- 当ok为true的时候，输出： Yes， 否则输出： No --&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; ok: true // true,返回：Yes， false=&gt; No &#125; &#125;);&lt;/script&gt; v-if指令可以根据数据绑定的情况进行插入标签或者移除标签。当然，如果熟悉js的都清楚，有if，肯定会有else。 Vue提供的是 v-else指令。 列表渲染基本v-for循环渲染标签模板引擎都会提供循环的支持。Vue也不例外，Vue是提供了一个v-for指令。基本的用法类似于foreach的用法。还是看例子最直接，上代码： 12345678910111213141516171819202122232425262728293031&lt;div id=\"app\"&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;地址&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!-- 每次for循环，都会创建一个tr标签。item是遍历的元素。 --&gt; &lt;tr v-for=\"item in UserList\" &gt; &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.age &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.address &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; UserList: [ &#123;'name': 'malun', 'age': 18, 'address': '北京黑地下室'&#125;, &#123;'name': 'flydragon', 'age': 22, 'address': '厦门的很多热的地方'&#125;, &#123;'name': 'temp', 'age': 25, 'address': '东北松花江上'&#125; ] &#125; &#125;);&lt;/script&gt; Template循环渲染多标签上面的例子，我们演示的是 每次循环输出一个tr标签。如果我们希望每次循环生成两个tr标签呢？如果还有生成其他的标签呢？ Vue给我们提供了template标签，供我们用于v-for循环中进行处理。 上代码喽：1234567&lt;ul&gt; &lt;!-- 通过template标签，可以一次循环，输出两个li标签 --&gt; &lt;template v-for=\"item in items\"&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class=\"divider\"&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; 表格显示的综合案例下面是一个综合的案例，每秒钟往表格中添加一条数据。本案例综合使用了v-if 和 v-for循环综合案例。 关于v-for对应的数组的更新由于Vue的机制就是检测数据的变化，自动跟新HTML。数组的变化，Vue之检测部分函数，检测的函数执行时才会触发视图更新。这些方法如下： push() pop() shift() unshift() splice() sort() reverse() 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue入门之动态显示表格&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;地址&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;!-- 如果列表有数据，直接输出表格数据，没有数据提示用户没有数据 --&gt; &lt;tbody v-if=\"UserList.length &gt; 0\"&gt; &lt;tr v-for=\"item in UserList\" &gt; &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.age &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.address &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tbody v-else&gt; &lt;tr&gt;&lt;td colspan=\"3\"&gt;没有数据奥！&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; UserList: [] &#125; &#125;); // 每秒钟插入一条数据。 setInterval(function () &#123; app.UserList.push(&#123;'name': 'malun', 'age': 18, 'address': '北京黑地下室'&#125;); &#125;, 1000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 总结列表和条件绑定列表的使用其实本质还是js的衍生使用，对于有js开发基础的没有什么难度。关键是多写几个案例就会详细通了。","categories":[{"name":"VueJS","slug":"VueJS","permalink":"http://yoursite.com/categories/VueJS/"}],"tags":[{"name":"Vuejs","slug":"Vuejs","permalink":"http://yoursite.com/tags/Vuejs/"},{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"},{"name":"Vue列表渲染及条件渲染","slug":"Vue列表渲染及条件渲染","permalink":"http://yoursite.com/tags/Vue列表渲染及条件渲染/"}]},{"title":"Vue(Vue实例详解与生命周期)","slug":"vue入门之Vue实例与生命周期","date":"2017-06-23T05:17:02.000Z","updated":"2017-06-24T02:46:58.000Z","comments":true,"path":"2017/06/23/vue入门之Vue实例与生命周期/","link":"","permalink":"http://yoursite.com/2017/06/23/vue入门之Vue实例与生命周期/","excerpt":"","text":"正文开始Vue实例详解与生命周期 Vue实例详解与生命周期Vue的实例是Vue框架的入口，其实也就是前端的ViewModel，它包含了页面中的业务逻辑处理、数据模型等，当然它也有自己的一系列的生命周期的事件钩子，辅助我们进行对整个Vue实例生成、编译、挂载、销毁等过程进行js控制。 Vue实例初始化的选项配置对象详解前面我们已经用了很多次 new Vue({...})的代码，而且Vue初始化的选项都已经用了data、methods、el、computed等,估计您看到这里时，应该已经都明白了他们的作用，我们就详细讲解一下他们的使用情况。更详细的请参考官网内容 Vue实例的data对象 介绍 Vue的实例的数据对象data 我们已经用了很多了，数据绑定离不开data里面的数据。也是Vue的核心属性。它是Vue绑定数据到HTML标签的数据源泉，另外Vue框架会自动监视data里面的数据变化，自动更新数据到HTML标签上去。本质原理是：Vue会自动将data里面的数据进行递归抓换成getter和setter，然后就可以自动更新HTML标签了，当然用getter和setter所以老的浏览器Vue支持的不够好。 data对象的类型： 类型是Object或者Function。 如果是组件对象中，data必须是Function类型。【后面学了组件后就明白了，暂时对组件先放放。】 实例： 123456789101112// 创建普通的Vue实例var vm = new Vue(&#123; data: data&#125;)// 组件定义【后面会详细讲的】// Vue.extend() 中 data 必须是函数var Component = Vue.extend(&#123; data: function () &#123; //这里必须是函数！！！！ return &#123; a: 1 &#125; &#125;&#125;) Vue实例的computed 介绍 Vue的计算属性（computed)的属性会自动混入Vue的实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。这就很强大了，然后计算属性中定义的函数里面可以直接使用指向了vue实例的this，非常方便的啊。 类型 { 键：函数}{ [key: string]: Function | { get: Function, set: Function } }当然，可以省略setter,如果省略了setter，那么值就可以是普通函数，但是必须有返回值。 官方的实例12345678910111213141516171819202122var vm = new Vue(&#123; data: &#123; a: 1 &#125;, computed: &#123; // 仅读取，值只须为函数 aDouble: function () &#123; return this.a * 2 &#125;, // 读取和设置 aPlus: &#123; get: function () &#123; return this.a + 1 &#125;, set: function (v) &#123; this.a = v - 1 &#125; &#125; &#125;&#125;)vm.aPlus // -&gt; 2vm.aPlus = 3vm.a // -&gt; 2vm.aDouble // -&gt; 4 methods 类型: { [key: string]: Function } 详细: methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。 注意，不应该使用箭头函数来定义 method 函数 (例如 plus: () =&gt; this.a++)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。 示例: 12345678910var vm = new Vue(&#123; data: &#123; a: 1 &#125;, methods: &#123; plus: function () &#123; this.a++ &#125; &#125;&#125;)vm.plus()vm.a // 2 watch 类型 { [key: string]: string | Function | Object } 详细: 一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。 示例: 1234567891011121314151617181920var vm = new Vue(&#123; data: &#123; a: 1, b: 2, c: 3 &#125;, watch: &#123; // 监控a变量变化的时候，自动执行此函数 a: function (val, oldVal) &#123; console.log('new: %s, old: %s', val, oldVal) &#125;, // 深度 watcher c: &#123; handler: function (val, oldVal) &#123; /* ... */ &#125;, deep: true &#125; &#125;&#125;)vm.a = 2 // -&gt; new: 2, old: 1//注意，不应该使用箭头函数来定义 watcher 函数 (例如 searchQuery: newValue =&gt; this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.updateAutocomplete 将是 undefined。 参考综合案例：12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue入门之数据监控&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; number &#125;&#125;&lt;/p&gt; &lt;input type=\"button\" name=\"btnGetNumber\" value=\"增加\" v-on:click=\"getNumber()\"&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; number: 1 &#125;, methods: &#123; // 事件响应方法的逻辑代码 getNumber: function (e) &#123; this.number += 1; // 不管是内联方法调用，还是绑定事件处理器两种方式执行事件响应方法的时候 this都是指向 app &#125; &#125;, watch: &#123; // 监控number的变化，并自动执行下面的函数 number: function (val, oldVal) &#123; console.log('val:' + val + ' - oldVal: ' + oldVal); &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 设置el的详解 类型 string | HTMLElement 限制： 只在由 new 创建的实例中遵守。 详细： 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标,也就是说Vue绑定数据到哪里去找。可以是CSS 选择器，也可以是一个 HTMLElement实例。 在实例挂载之后(生命周期的内容后面会详细讲的奥)， 元素可以用 vm.$el 访问。 如果这个选项在实例化时有作用，实例将立即进入编译过程，否则，需要显式调用 vm.$mount() 手动开启编译。 12345// 几乎所有例子都用到这个，所以就不再赘述var app = new Vue(&#123; el: '#app', ...&#125;); Vue实例的生命周期Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、卸载等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。 在Vue的整个生命周期中，它提供了一系列的事件，可以让我们注册js方法，可以让我们达到控制整个过程的目的地，哇赛，如果你搞过Asp.Net WebForm的话，你会发现整个就是WebForm的翻版嘛哈哈。值得注意的是，在这些事件响应方法中的this直接指向的是vue的实例。 首先看看下面官网的一张生命周期的图，我做一下标注，看看整体的流程，后面我们上代码做一下效果。 Vue提供的可以注册的钩子都在上图片的红色框标注。他们是： beforeCreate 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。 created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 接下来我们做一个例子，看一下Vue中所有的生命周期怎么用的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue入门之生命周期&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; number &#125;&#125;&lt;/p&gt; &lt;input type=\"text\" name=\"btnSetNumber\" v-model=\"number\"&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; number: 1 &#125;, beforeCreate: function () &#123; console.log('beforeCreate 钩子执行...'); console.log(this.number) &#125;, cteated: function () &#123; console.log('cteated 钩子执行...'); console.log(this.number) &#125;, beforeMount: function () &#123; console.log('beforeMount 钩子执行...'); console.log(this.number) &#125;, mounted: function () &#123; console.log('mounted 钩子执行...'); console.log(this.number) &#125;, beforeUpdate: function () &#123; console.log('beforeUpdate 钩子执行...'); console.log(this.number) &#125;, updated: function () &#123; console.log('updated 钩子执行...'); console.log(this.number) &#125;, beforeDestroy: function () &#123; console.log('beforeDestroy 钩子执行...'); console.log(this.number) &#125;, destroyed: function () &#123; console.log('destroyed 钩子执行...'); console.log(this.number) &#125;, &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 再看一个综合的实战的例子，可能涉及到ajax和组件，不过先看一下vue的生命周期的例子的用法： 123456789101112131415161718192021import Axios from 'axios' // 这是一个轻量级的ajax库，import是es6模块导入的语法。export default &#123; // 这是一个vue的模块，后面讲奥。 name: 'app', components: &#123; &#125;, data: function () &#123; return &#123; list: [] &#125; &#125;, mounted: function () &#123; // 挂在完成后的生命周期钩子注册。 this.$nextTick(function () &#123; // 等待下一次更新完成后执行业务处理代码。 Axios.get('/api/menulist', &#123;// 将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新 params: &#123; &#125; &#125;).then(function (res) &#123; this.list = res.data &#125;.bind(this)) &#125;) &#125;&#125; Vue实例的全局配置这一块都是一些小的知识点，我就不赘述了，直接copy 官网Vue.config 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列属性： silent 类型： boolean 默认值： false 用法： 12Vue.config.silent = true//取消 Vue 所有的日志与警告。 optionMergeStrategies 类型： { [key: string]: Function } 默认值： {} 用法： 123456789Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) &#123; return child + 1&#125;const Profile = Vue.extend(&#123; _my_option: 1&#125;)// Profile.options._my_option = 2//自定义合并策略的选项。//合并策略选项分别接受第一个参数作为父实例，第二个参数为子实例，Vue实例上下文被作为第三个参数传入。 devtools 类型： boolean 默认值： true (生产版为 false) 用法： 123// 务必在加载 Vue 之后，立即同步设置以下内容Vue.config.devtools = true//配置是否允许 vue-devtools 检查代码。开发版本默认为 true，生产版本默认为 false。生产版本设为 true 可以启用检查。 errorHandler 类型： Function 默认值： 默认抛出错误 用法： 12345Vue.config.errorHandler = function (err, vm) &#123; // handle error&#125;//指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。//Sentry, an error tracking service, provides official integration using this option. ignoredElements 类型: Array 默认值: [] 用法: 1234Vue.config.ignoredElements = [ 'my-custom-web-component', 'another-web-component']须使 Vue 忽略在 Vue 之外的自定义元素 (e.g., 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 Unknown custom element 的警告。 keyCodes 类型： { [key: string]: number | Array } 默认值： {} 用法： 1234567Vue.config.keyCodes = &#123; v: 86, f1: 112, mediaPlayPause: 179, up: [38, 87]&#125;//给 v-on 自定义键位别名。 Vue的全局API Vue的全局API提供大量的功能，我这里就给大家罗列几个常用的结果，其他的还是参考官网. Vue.nextTick语法： Vue.nextTick( [callback, context] ) 123参数：&#123;Function&#125; [callback]&#123;Object&#125; [context] 用法：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 123456// 修改数据vm.msg = 'Hello'// DOM 还没有更新Vue.nextTick(function () &#123; // DOM 更新了&#125;) Vue.set语法： Vue.set( object, key, value ) 12345参数：&#123;Object&#125; object&#123;string&#125; key&#123;any&#125; value返回值： 设置的值. 用法：设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开 Vue 不能检测属性被添加的限制。注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。 Vue.compile 语法：Vue.compile( template ) 参数： {string} template 用法：12345678910//在render函数中编译模板字符串。只在独立构建时有效var res = Vue.compile('&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;')new Vue(&#123; data: &#123; msg: 'hello' &#125;, render: res.render, staticRenderFns: res.staticRenderFns&#125;) 全局API总结其实还有几个其他的全局API，不打算在这里讲了，比如扩展组件Vue.extend 的用法、Vue.use加载插件、Vue.filter加载过滤器、Vue.directive自定义指令等后面再讲其他Vue的知识点的时候，再加上这些，全局API其实就是Vue类型的静态方法，全局范围内都可以使用的，某些实例的方法本质也是调用了这些全局的，后面用到时候再说。 Vue实例与生命周期总结Vue的实例封装的还是挺有艺术性的，很符合开发者的思维规范，它的生命周期也非常清晰，使用起来也非常方便。Vue确实一个好框架。","categories":[{"name":"VueJS","slug":"VueJS","permalink":"http://yoursite.com/categories/VueJS/"}],"tags":[{"name":"Vuejs","slug":"Vuejs","permalink":"http://yoursite.com/tags/Vuejs/"},{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"},{"name":"Vue实例详解，Vue生命周期","slug":"Vue实例详解，Vue生命周期","permalink":"http://yoursite.com/tags/Vue实例详解，Vue生命周期/"}]},{"title":"Vue(Vue事件处理)","slug":"Vue入门之事件绑定处理","date":"2017-06-23T05:17:02.000Z","updated":"2017-09-06T08:20:36.000Z","comments":true,"path":"2017/06/23/Vue入门之事件绑定处理/","link":"","permalink":"http://yoursite.com/2017/06/23/Vue入门之事件绑定处理/","excerpt":"","text":"正文开始Vue入门之事件处理 Vue事件处理监听事件的Vue处理Vue提供了协助我们为标签绑定时间的方法，当然我们可以直接用dom原生的方式去绑定事件。Vue提供的指令进行绑定也是非常方便，而且能让ViewModel更简洁，逻辑更彻底。所以还是推荐大家使用的。 Vue提供了v-on指令帮助我们进行事件的绑定。基本的内联事件处理方法[官方demo]： 12345678910111213&lt;div id=\"example-1\"&gt; &lt;!-- 为按钮绑定点击事件，执行counter += 1的任务。 --&gt; &lt;button v-on:click=\"counter += 1\"&gt;增加 1&lt;/button&gt; &lt;p&gt;这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var example1 = new Vue(&#123; el: '#example-1', data: &#123; counter: 0 &#125;&#125;)&lt;/script&gt; 事件处理方法集成到Vue对象内联的方式绑定的事件，只能处理简单的事件的处理逻辑。复杂的情况还是封装到js中最方便，也不容易出错。Vue对象中可以添加methods属性，开发者可以把事件处理函数的逻辑放到methods中。 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue入门之动态显示表格&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; number &#125;&#125;&lt;/p&gt; &lt;input type=\"button\" name=\"btnGetNumber\" value=\"增加[绑定事件处理器]\" v-on:click=\"getNumber\"&gt; &lt;input type=\"button\" name=\"btnGetNumber\" value=\"增加[内联方法调用]\" v-on:click=\"getNumber()\"&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; number: 1 &#125;, methods: &#123; // 事件响应方法的逻辑代码 getNumber: function (e) &#123; this.number += 1; // 不管是内联方法调用，还是绑定事件处理器两种方式执行事件响应方法的时候 this都是指向 app &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件修饰符官网上写的非常好，这块就直接用管网的吧。在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在 methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。为了解决这个问题， Vue.js 为 v-on 提供了 事件修饰符。通过由点(.)表示的指令后缀来调用修饰符。 .stop .prevent .capture .self .once 1234567891011121314&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt;&lt;!-- the click event will be triggered at most once --&gt;&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt; 按键修饰符在监听键盘事件时，我们经常需要监测常见的键值。 Vue 允许为 v-on 在监听键盘事件时添加按键修饰符： 1234567&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13=\"submit\"&gt;记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter=\"submit\"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter=\"submit\"&gt; 全部的按键别名： .enter .tab .delete (捕获 “删除” 和 “退格” 键) .esc .space .up .down .left .right .ctrl .alt .shift .meta 事件绑定的简写Vue中属性的绑定的简写直接是: === ‘v-bind:’而事件的缩写是直接变成@. 也就是说： v-on: === @看下面的例子：1234&lt;!-- 完整语法 --&gt;&lt;a v-on:click=\"doSomething\"&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=\"doSomething\"&gt;&lt;/a&gt; 事件绑定总结Vue为了方便大家进行开发，提供了事件的相关的封装，可以让我们方便我们用Vue对事件进行开发，尤其是v-on指令的非常方便的跟Vue对象中methods进行配合进行复杂的事件处理，非常方便。另外事件的事件修饰符和按键修饰符也可以让Vue事件这块锦上添花。","categories":[{"name":"VueJS","slug":"VueJS","permalink":"http://yoursite.com/categories/VueJS/"}],"tags":[{"name":"Vuejs","slug":"Vuejs","permalink":"http://yoursite.com/tags/Vuejs/"},{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"},{"name":"Vue事件处理","slug":"Vue事件处理","permalink":"http://yoursite.com/tags/Vue事件处理/"}]},{"title":"Vue(入门及简介)","slug":"vue入门简介","date":"2017-06-23T05:17:02.000Z","updated":"2017-06-24T02:46:52.000Z","comments":true,"path":"2017/06/23/vue入门简介/","link":"","permalink":"http://yoursite.com/2017/06/23/vue入门简介/","excerpt":"","text":"正文开始Vue简介及入门 Vue入门之概念及HelloworldVue简介Vue是一个前端的双向绑定类的框架，发音[读音 /vjuː/, 类似于 view]。新的Vue版本参考了React的部分设计，当然也有自己独特的地方，比如Vue的单文件组件开发方式都很有创新，另外Vue自身的一些绑定的语法、用法等都非常精炼，很容易上手，而且第三方的插件都非常丰富，社区非常活跃，最新的文档都有中文版本。而且Vue配合官方的和第三方的库可以实现单文件的组件化开发、SPA等现代化前端开发。详情请参考Vue官网 Vue的入门demoVue 可以直接把它当做一个js库使用，所以它可以很容易的接入到你的项目或者单个页面中。甚至你可以只使用它的双向绑定功能。所以它很容易上手。 比如：我们有一个需求，一个网页上一个Div标签，我们有一个json对象存储数据，把json对象上的数据放到Div上去。 接下来是步骤：12345678910第一步： 创建一个文件夹并创建一个html文件 比如：index.html.当如你可以选择你自己的编辑器，我就用VSCode。第二步：引入Vue库&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;当然了你可以直接下载Vue的js文件，推荐你直接用上面的cdn即可。第三步：创建一个Div，给它一个id，比如：app第四步：创建Vue的对象，并把数据绑定到上面创建好的div上去。 最终的代码如下：1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt; &lt;!--第一步：创建文件夹及html文件--&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue入门之Helloworld&lt;/title&gt; &lt;!--第二步：引入Vue库--&gt; &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--第三步:创建一个Div--&gt; &lt;div id=\"app\"&gt; &lt;!--Vue的模板的绑定数据的方法， 类似于很多其他前端的模板，可以用两对花括号进行绑定Vue中的数据对象的属性 --&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &lt;!--第四步：创建Vue的对象，并把数据绑定到上面创建好的div上去。--&gt; &lt;script&gt; var app = new Vue(&#123; // 创建Vue对象。Vue的核心对象。 el: '#app', // el属性：把当前Vue对象挂载到 div标签上，#app是id选择器 data: &#123; // data: 是Vue对象中绑定的数据 message: 'Hello Vue!' // message 自定义的数据 &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最终的结果就是：1Hello Vue! Vue的Helloworld总结 Vue构造函数的：选项el属性，就是element缩写，当前Vue对象挂载到哪个标签上的语法，支持CSS选择器或者dom对象，一般用id选择器选择当前页面的标签。 Vue的选项：data属性是自定义数据。这里我们只是演示了一个message属性，vue会把自定义的数据可以与html的模板数据进行绑定。 Vue 数据绑定的方式就是用&#123;&#123; &#125;&#125;，类似于handlebars. 上面这个demo就是演示了Vue的绑定数据的基本模型。注意点，标签先创建好了之后，再创建Vue对象，具体你应该懂吧。","categories":[{"name":"VueJS","slug":"VueJS","permalink":"http://yoursite.com/categories/VueJS/"}],"tags":[{"name":"Vuejs","slug":"Vuejs","permalink":"http://yoursite.com/tags/Vuejs/"},{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"},{"name":"Vue的入门简介","slug":"Vue的入门简介","permalink":"http://yoursite.com/tags/Vue的入门简介/"}]},{"title":"Vue(数据绑定)","slug":"vue数据绑定","date":"2017-06-23T05:17:02.000Z","updated":"2017-06-23T11:44:30.000Z","comments":true,"path":"2017/06/23/vue数据绑定/","link":"","permalink":"http://yoursite.com/2017/06/23/vue数据绑定/","excerpt":"","text":"正文开始Vue数据绑定 Vue入门之数据绑定什么是双向绑定？Vue框架很核心的功能就是双向的数据绑定。双向是指：HTML标签数据 绑定到 Vue对象，另外反方向数据也是绑定的。通俗点说就是，Vue对象的改变会直接影响到HTML的标签的变化，而且标签的变化也会反过来影响Vue对象的属性的变化。这样以来，就彻底变革了之前Dom的开发方式，之前Dom驱动的开发方式尤其是以jQuery为主的开发时代，都是dom变化后，触发js事件，然后在事件中通过js代码取得标签的变化，再跟后台进行交互，然后根据后台返回的结果再更新HTML标签，异常的繁琐。有了Vue这种双向绑定，让开发人员只需要关心json数据的变化即可，Vue自动映射到HTML上，而且HTML的变化也会映射回js对象上，开发方式直接变革成了前端由数据驱动的开发时代，远远抛弃了Dom开发主导的时代了。 Vue绑定文本数据绑定最常见的形式就是使用 “Mustache” 语法（双大括号）的文本插值，比如模板引擎：handlebars中就是用的&#123;&#123; &#125;&#125;.创建的Vue对象中的data属性就是用来绑定数据到HTML的。参考如下代码：123456789&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;script&gt; var app = new Vue(&#123; // 创建Vue对象。Vue的核心对象。 el: '#app', // el属性：把当前Vue对象挂载到 div标签上，#app是id选择器 data: &#123; // data: 是Vue对象中绑定的数据 msg: 'Hello Vue!' // message 自定义的数据 &#125; &#125;);&lt;/script&gt; 绑定数据中使用JavaScript表达式对于所有的数据绑定， Vue.js 都提供了完全的 JavaScript 表达式支持。 12345678910&lt;span&gt;Message: &#123;&#123; msg + ' - ' + name &#125;&#125;&lt;/span&gt;&lt;script&gt; var app = new Vue(&#123; // 创建Vue对象。Vue的核心对象。 el: '#app', // el属性：把当前Vue对象挂载到 div标签上，#app是id选择器 data: &#123; // data: 是Vue对象中绑定的数据 msg: 'Hi', // message 自定义的数据 name: 'flydragon' // name自定义的属性，vue可以多个自定义属性，属性类型也可是复杂类型 &#125; &#125;);&lt;/script&gt; 结果：1Hi - flydragon 当然Vue还可以支持表达中的任何计算、函数处理等。参考下面的综合点的案例。 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue入门之数据绑定-表达式运算&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &#123;&#123; msg + ' - ' + name &#125;&#125; &lt;p&gt; &#123;&#123; isOk ? '123' : '456' &#125;&#125; &lt;/p&gt; &lt;p&gt;我的年龄是： &#123;&#123; age *2 &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; // 创建Vue对象。Vue的核心对象。 el: '#app', // el属性：把当前Vue对象挂载到 div标签上，#app是id选择器 data: &#123; // data: 是Vue对象中绑定的数据 msg: 'Hi', // message 自定义的数据 name: 'flydragon', isOk: true, age: 18 &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue属性绑定Vue中不能直接使用&#123;&#123;expression &#125;&#125; 语法进行绑定html的标签，而是用它特有的v-bind指令（就是一种写法，先按照格式走，具体指令是什么可以后续再了解）。 绑定的语法结构：123&lt;标签 v-bind:属性名=&quot;要绑定的Vue对象的data里的属性名&quot;&gt;&lt;/标签&gt;例如:&lt;span v-bind:id=&quot;menuId&quot;&gt;&#123;&#123; menuName &#125;&#125;&lt;/span&gt; 参考如下代码案例：12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue入门之数据绑定--属性绑定&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div v-bind:id=\"MenuContaineId\"&gt; &lt;a href=\"#\" v-bind:class=\"MenuClass\"&gt;首页&lt;/a&gt; &lt;a href=\"#\" v-bind:class=\"MenuClass\"&gt;产品&lt;/a&gt; &lt;a href=\"#\" v-bind:class=\"MenuClass\"&gt;服务&lt;/a&gt; &lt;a href=\"#\" v-bind:class=\"MenuClass\"&gt;关于&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; // data: 是Vue对象中绑定的数据 MenuClass: 'top-menu', MenuContaineId: 'sitemenu' &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 输出纯HTML由于Vue对于输出绑定的内容做了提前encode，保障在绑定到页面上显示的时候不至于被xss攻击。但某些场景下，我们确保后台数据是安全的，那么我们就要在网页中显示原生的HTML标签。Vue提供了v-html指令。 12345678910111213&lt;div id=\"app\"&gt; &lt;div v-bind:id=\"MenuContaineId\" v-html=\"MenuBody\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; // data: 是Vue对象中绑定的数据 MenuContaineId: 'menu', MenuBody: '&lt;p&gt;这里是菜单的内容&lt;/p&gt;' &#125; &#125;);&lt;/script&gt; 结果：12345&lt;div id=\"app\"&gt; &lt;div id=\"menu\"&gt; &lt;p&gt;这里是菜单的内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 样式绑定对于普通的属性的绑定，只能用上面的讲的绑定属性的方式。而Vue专门加强了class和style的属性的绑定。可以有复杂的对象绑定、数组绑定样式和类。 绑定样式对象经常我们需要对样式进行切换，比如：div的显示和隐藏，某些标签active等。Vue提供的对象绑定样式的方式就很容做这些事情。1234代码：&lt;div v-bind:class=\"&#123; active: isActive &#125;\"&gt;&lt;/div&gt;解释：当 isActive为 true时， div就会具有了active样式类，如果 isActive为false，那么div就去掉active样式类。 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue入门之绑定样式类&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt; &lt;style&gt; .active &#123; background-color: #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div v-bind:id=\"MenuContaineId\" v-bind:class=\"&#123; active: isActive &#125;\"&gt; 绑定颜色类 &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; // data: 是Vue对象中绑定的数据 MenuContaineId: 'menu', isActive: true &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 混合普通的HTML标签样式类及绑定样式对象v-bind:class 指令可以与普通的 class 属性共存。1234567891011121314&lt;div id=\"app\"&gt; &lt;div class=\"static\" v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; // data: 是Vue对象中绑定的数据 isActive: true, hasError: false &#125; &#125;);&lt;/script&gt; 结果：1234&lt;div id=\"app\"&gt; &lt;div class=\"static active\"&gt; &lt;/div&gt;&lt;/div&gt; 绑定data中的样式对象直接在html属性中的双引号内写对象，还是很不爽，也没有智能提示，很容易写错。Vue可以让我们直接把绑定的class字符串指向data的一个对象，这样就非常方便了，既可以有智能提示，又可以很复杂进行编辑，不用担心烦人的&quot;&quot;了。 12345678910111213141516&lt;div id=\"app\"&gt; &lt;div class=\"static\" v-bind:class=\"classObject\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; classObject: &#123; active: true, 'text-danger': false &#125; &#125; &#125;);&lt;/script&gt; 结果：1234&lt;div id=\"app\"&gt; &lt;div class=\"static active\"&gt; &lt;/div&gt;&lt;/div&gt; 绑定样式数组其实绑定数组，就是绑定样式对象的延续，看官网的例子代码吧。123456&lt;div v-bind:class=\"[activeClass, errorClass]\"&gt;data: &#123; activeClass: 'active', errorClass: 'text-danger'&#125; 当然还有很多其他很有趣的支持，就不赘述了。123例如:&lt;div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"&gt;&lt;div v-bind:class=\"[&#123; active: isActive &#125;, errorClass]\"&gt; 内联样式绑定内联样式的绑定，非常类似于样式类的操作。v-bind:style 的对象语法十分直观——看着非常像 CSS ，其实它是一个 JavaScript 对象。 CSS属性名可以用驼峰式（camelCase）或短横分隔命名（kebab-case）。 看个例子：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue入门之htmlraw&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div v-bind:style=\"&#123;fontSize: size + 'px', backgroundColor: bgcolor, width: width&#125;\"&gt; vue 入门系列教程 &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; size: 19, width: 200, bgcolor: 'red' &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 自动添加前缀当 v-bind:style 使用需要特定前缀的 CSS 属性时，如 transform ，Vue.js 会自动侦测并添加相应的前缀。 计算属性在做数据的绑定的时候,数据要进行处理之后才能展示到html页面上，虽然vue提供了非常好的表达式绑定的方法，但是只能应对低强度的需求。比如： 把一个日期按照规定格式进行输出，可能就需要我们对日期对象做一些格式化的出来，表达式可能就捉襟见肘了。 Vue对象提供的computed属性，可以让我们开发者在里面可以放置一些方法，协助我们绑定数据操作，这些方法可以跟data中的属性一样用，注意这些方法用的时候不要加()。例子来了：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue入门之htmlraw&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;table&gt; &lt;tr&gt; &lt;!-- computed里面的函数可以直接当成data里面的属性用，非常方便，注意没有括号！！！--&gt; &lt;td&gt;生日&lt;/td&gt;&lt;td&gt;&#123;&#123; getBirthday &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;年龄&lt;/td&gt;&lt;td&gt;&#123;&#123; age &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;地址&lt;/td&gt;&lt;td&gt;&#123;&#123; address &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; birthday: 914228510514, // 这是一个日期对象的值：1998年11月1日 age: 19, address: '北京昌平区龙泽飞龙' &#125;, computed: &#123; // 把日期换成 常见规格格式的字符串。 getBirthday: function () &#123; var m = new Date(this.birthday); return m.getFullYear() + '年' + m.getMonth() +'月'+ m.getDay()+'日'; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 绑定的数据过滤器过滤器本质就是数据在呈现之前先进行过滤和筛选。官网上写的不错，我就不再赘述，下面是官网的描述。 Vue.js 允许你自定义过滤器，被用作一些常见的文本格式化。过滤器应该被添加在 mustache 插值的尾部，由“管道符”指示：1234567891011121314151617181920212223&#123;&#123; message | capitalize &#125;&#125;&lt;!-- in mustaches --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- in v-bind --&gt;&lt;div v-bind:id=\"rawId | formatId\"&gt;&lt;/div&gt;Vue 2.x 中，过滤器只能在 mustache 绑定和 v-bind 表达式（从 2.1.0 开始支持）中使用，因为过滤器设计目的就是用于文本转换。为了在其他指令中实现更复杂的数据变换，你应该使用计算属性。过滤器函数总接受表达式的值作为第一个参数。new Vue(&#123; // ... filters: &#123; capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125;&#125;)过滤器可以串联：&#123;&#123; message | filterA | filterB &#125;&#125;过滤器是 JavaScript 函数，因此可以接受参数：&#123;&#123; message | filterA('arg1', arg2) &#125;&#125;这里，字符串 'arg1' 将传给过滤器作为第二个参数， arg2 表达式的值将被求值然后传给过滤器作为第三个参数。 核心：自动响应对象的变化到HTML标签上面的例子都是 数据对象是写死在创建的Vue对像上，那如果数据（data）发生改变时会怎样呢？让我们用chrome把上面例子的页面打开，并打开发者工具控制台,输入：app.age = 20 会有什么情况发生呢？ 在页面中添加一个按钮，动态的增加年龄： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue入门之htmlraw&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;table&gt; &lt;tr&gt; &lt;!-- computed里面的函数可以直接当成data里面的属性用，非常方便，注意没有括号！！！--&gt; &lt;td&gt;生日&lt;/td&gt;&lt;td&gt;&#123;&#123; getBirthday &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;年龄&lt;/td&gt;&lt;td&gt;&#123;&#123; age &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;地址&lt;/td&gt;&lt;td&gt;&#123;&#123; address &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;!-- 添加下面这行代码，动态增加 年龄，页面会有怎样的变化呢？？ --&gt; &lt;button type=\"button\" onclick=\"app.age+=1;\" &gt;加加&lt;/button&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; birthday: 914228510514, // 这是一个日期对象的值：1998年11月1日 age: 19, address: '北京昌平区龙泽飞龙' &#125;, computed: &#123; // 把日期换成 常见规格格式的字符串。 getBirthday: function () &#123; var m = new Date(this.birthday); return m.getFullYear() + '年' + m.getMonth() +'月'+ m.getDay()+'日'; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 双向数据绑定上面的例子我们大多讲的是单向的 js对象向 HTML数据进行绑定，那HTML怎样向js进行反馈数据呢？HTML中只有表达能接受用户的输入，最简单的演示双向绑定的就是文本框了。 Vue提供了一个新的指令：v-model进行双向数据的绑定，注意不是v-bind。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue入门之htmlraw&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- v-model可以直接指向data中的属性，双向绑定就建立了 --&gt; &lt;input type=\"text\" name=\"txt\" v-model=\"msg\"&gt; &lt;p&gt;您输入的信息是：&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; msg: '双向数据绑定的例子' &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最终的结果就是：你改变input文本框的内容的时候，p标签中的内容会跟着进行改变，哇是不是很神奇呢… 关于其他表单的绑定的语法我就不赘述了，还是参考官网吧，我这里大部分例子也是来自官网。 数据绑定总结vue提供了大量的绑定的语法和方法，非常方便我们进行数据的绑定，尤其它是双向的数据绑定，极大的减少了我们dom操作的麻烦程度。可能你越来越喜欢它了吧…","categories":[{"name":"VueJS","slug":"VueJS","permalink":"http://yoursite.com/categories/VueJS/"}],"tags":[{"name":"Vuejs","slug":"Vuejs","permalink":"http://yoursite.com/tags/Vuejs/"},{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"},{"name":"Vue的数据绑定","slug":"Vue的数据绑定","permalink":"http://yoursite.com/tags/Vue的数据绑定/"}]},{"title":"Vue(Vue入门之组件化开发)","slug":"Vue入门之组件化","date":"2017-06-23T05:17:02.000Z","updated":"2017-06-24T06:21:14.000Z","comments":true,"path":"2017/06/23/Vue入门之组件化/","link":"","permalink":"http://yoursite.com/2017/06/23/Vue入门之组件化/","excerpt":"","text":"正文开始Vue入门之组件化开发 Vue入门之组件化开发组件其实就是一个拥有样式、动画、js逻辑、HTML结构的综合块。前端组件化确实让大的前端团队更高效的开发前端项目。而作为前端比较流行的框架之一，Vue的组件和也做的非常彻底，而且有自己的特色。尤其是她单文件组件开发的方式更是非常方便，而且第三方工具支持也非常丰富，社区也非常活跃，第三方组件也呈井喷之势。当然学习和使用Vue的组件也是我们的最重要的目标。 全局扩展方法Vue.extendVue提供了一个全局的API，Vue.extend可以帮助我们对Vue实例进行扩展，扩展完了之后，就可以用此扩展对象创建新的Vue实例了。类似于继承的方式。12345678910语法：Vue.extend( options )参数：&#123;Object&#125; options用法：使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象[后面会细讲]。data 选项是特例，需要注意 - 在 Vue.extend() 中它必须是函数 下面是一个官网demo：123456789101112131415161718192021222324&lt;div id=\"mount-point\"&gt;&lt;/div&gt;&lt;script&gt;// 创建构造器var Profile = Vue.extend(&#123; // 新的对象的模板，所有子实例都会拥有此模板 template: '&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;', data: function () &#123; // 创建的Vue实例时，data可以是Object 也可以是Function，但是在扩展 return &#123; // 的时候，data必须是一个函数，而且要返回值奥。 firstName: 'Walter', lastName: 'White', alias: 'Heisenberg' &#125; &#125;&#125;)&lt;/script&gt;// 创建 Profile 实例，并挂载到一个元素上。new Profile().$mount('#mount-point')// .$mount() 方法跟设置 el属性效果是一致的。结果如下：&lt;p&gt;Walter White aka Heisenberg&lt;/p&gt; 综合案例代码：123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue入门之extend全局方法&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;/div&gt; &lt;script&gt; var myVue = Vue.extend(&#123; template: '&lt;div&gt;&#123;&#123; name &#125;&#125; - &#123;&#123; age &#125;&#125; - &#123;&#123; mail &#125;&#125;&lt;/div&gt;', data: function () &#123; return &#123; name: 'malun', age: '19', mail: 'flydragonml@gmail.com' &#125;; &#125; &#125;); var app = new myVue(&#123; el: '#app' &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 创建组件和注册组件当然上面的方式只是能让我们继承Vue实例做一些扩展的动作。看Vue中如何创建一个组件并注册使用。 Vue提供了一个全局注册组件的方法：Vue.component。 123456789101112131415语法： Vue.component( id, [definition] )参数： &#123;string&#125; id 组件的名字，可以当HTML标签用，注意组件的名字都是小写，而且最好有横线和字母组合。 &#123;Function | Object&#125; [definition] 组件的设置用法：注册或获取全局组件。注册还会自动使用给定的id设置组件的名称// 注册组件，传入一个扩展过的构造器Vue.component(&apos;my-component&apos;, Vue.extend(&#123; /* ... */ &#125;))// 注册组件，传入一个选项对象（自动调用 Vue.extend）Vue.component(&apos;my-component&apos;, &#123; /* ... */ &#125;)// 获取注册的组件（始终返回构造器）var MyComponent = Vue.component(&apos;my-component&apos;) 简单demo： 1234&lt;div id=\"example\"&gt; &lt;!--组件直接跟普通的标签一样的使用。--&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt; 123456789// 注册一个组件Vue.component('my-component', &#123; // 模板选项设置当前组件，最终输出的html模板。注意：有且只有一个根元素。 template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#example'&#125;) 那么我们注册一个组件自动帮我生成 label和radiobutton组合。123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue入门之extend全局方法&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!--组件名直接可以当标签使用。--&gt; &lt;radio-tag rid=\"rBas\" txt=\"篮球\" val=\"1\"&gt;&lt;/radio-tag&gt; &lt;!--组件的属性也可以使用Vue的绑定的语法，下面是动态绑定数据给子组件--&gt; &lt;radio-tag :rid=\"demoId\" :txt=\"demoText\" :val=\"demoVal\"&gt;&lt;/radio-tag&gt; &lt;/div&gt; &lt;script&gt; // 定义组件模板，模板必须有且只有一个根元素。 var temp = '&lt;div&gt;&lt;label v-bind:for=\"rid\"&gt;&#123;&#123; txt &#125;&#125;&lt;/label&gt;&lt;input :id=\"rid\" type=\"radio\" v-bind:value=\"val\"&gt;&lt;/div&gt;'; // 注册一个全局的组件 Vue.component('radio-tag', &#123; // 组件的名字不能有大写字母，跟React的曲别啊。另外组件名最好是小写字母加横线组合。 template: temp, props: ['rid', 'txt', 'val'], // 设置组件的属性有哪些，定义标签的属性一致。 data: function () &#123; // 注意属性名都得是小写，不然会不认的。 return &#123; // 在组件的定义中data必须是函数，而且必须有返回值。 age: 19, // 此地方的 age 和 emial都是演示，并么有有到。 email: 'flydragonml@gmail.com' &#125; &#125; &#125;); // 初始化一个Vue实例 var app = new Vue(&#123; el: '#app', data: &#123; demoId: 'ft', demoText: '足球', demoVal: 2 &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意结果点 组件的名字都必须是小写【其实是非必须，但是为了不麻烦就强制吧】！！！而且建议是小写字母和横线的组合比如： my-radiobtn 注册组件的时候，可以传入一个选项对象进行配置。其中props是设置当前组件的属性，属性也都必须小写。属性是连接父容器和子组件的桥梁。 注意：属性名和组件的名字都要小写啊，不然vue不会认的。 编写组件代码最好配合Vue的chrome插件：vue-devtool 组件可以返还自己的数据，但是必须是函数。data必须是Function 局部注册组件全局注册组件就是使用全局API Vue.componet(id, {....})就行了，当然我们有时候需要注册一个局部模块的自己用的组件。那么就可以用下面的方式了。 12345678910var Child = &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;new Vue(&#123; // ... components: &#123; // &lt;my-component&gt; 将只在父模板可用 'my-component': Child &#125;&#125;) 组件的slot使用组件的时候，经常需要在父组件中为子组件中插入一些标签等。当然其实可以通过属性等操作，但是比较麻烦，直接写标签还是方便很多。那么Vue提供了slot协助子组件对父容器写入的标签进行管理。 当父容器写了额外的内容时， 如果子组件恰好有一个slot标签，那边子容器的slot标签会被父容器写入的内容替换掉。 比如下面的例子：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Vue入门之extend全局方法&lt;/title&gt; &lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!--父容器输入标签--&gt; &lt;my-slot&gt; &lt;h3&gt;这里是父容器写入的&lt;/h3&gt; &lt;/my-slot&gt; &lt;!--父容器绑定数据到子容器的slot,这里的作用域是父容器的啊。--&gt; &lt;my-slot&gt;&#123;&#123; email &#125;&#125;&lt;/my-slot&gt; &lt;!--父容器什么都不传内容--&gt; &lt;my-slot&gt;&lt;/my-slot&gt; &lt;/div&gt; &lt;script&gt; // 反引号：可以定义多行字符串。 var temp = ` &lt;div&gt; &lt;h1&gt;这里是子组件&lt;/h1&gt; &lt;hr&gt; &lt;slot&gt;slot标签会被父容器写的额外的内容替换掉，如果父容器没有写入任何东西，此标签将保留！&lt;/slot&gt; &lt;/div&gt; `; Vue.component('MySlot', &#123; // 如果定义的组件为MySlot，那么用组件的时候：&lt;my-slot&gt;&lt;/my-slot&gt; template: temp, &#125;); // 初始化一个Vue实例 var app = new Vue(&#123; el: '#app', data: &#123; email: 'flydragon@gmail.com' &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最终结果：1234567891011121314151617&lt;div id=\"app\"&gt; &lt;div&gt; &lt;h1&gt;这里是子组件&lt;/h1&gt; &lt;hr&gt; &lt;h3&gt;这里是父容器写入的&lt;/h3&gt; &lt;/div&gt; &lt;div&gt; &lt;h1&gt;这里是子组件&lt;/h1&gt; &lt;hr&gt; flydragon@gmail.com &lt;/div&gt; &lt;div&gt; &lt;h1&gt;这里是子组件&lt;/h1&gt; &lt;hr&gt; slot标签会被父容器写的额外的内容替换掉，如果父容器没有写入任何东西，此标签将删除！ &lt;/div&gt;&lt;/div&gt; 单文件组件的使用方式介绍通过上面我们定义组件的方式，就已经感觉很不爽了，尤其是模板的定义，而且样式怎么处理也没有很好的进行规整。Vue可以通过Webpack等第三方工具实现单文件的开发的方式。当然这里会牵扯到很多es6的语法、第三方工具实现前端模块化等很多知识，我们大概看一眼指导Vue的组件可以直接写一个文件中，其他地方就可以直接导入这个模块了。后面做项目的时候我还会再讲一下怎么用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;template&gt; &lt;div&gt; &lt;nav class=\"navbar navbar-dark navbar-fixed-top\"&gt; &lt;/nav&gt; &lt;div class=\"col-md-3 sidebar\"&gt; &lt;ul&gt; &lt;li v-for=\"item in list\" &gt; &lt;router-link :to=\"&#123; path: item.url &#125;\"&gt;&#123;&#123; item.name &#125;&#125;&lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"container-fluid content\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 这里怎么回事import Axios from 'axios'export default &#123; name: 'app', components: &#123; &#125;, data: function () &#123; return &#123; list: [] &#125; &#125;, mounted: function () &#123; // 挂载完成后 this.$nextTick(function () &#123; Axios.get('/api/menulist', &#123; params: &#123; &#125; &#125;).then(function (res) &#123; this.list = res.data &#125;.bind(this)) &#125;) &#125;&#125;&lt;/script&gt;&lt;style&gt;ul, li &#123; list-style: none;&#125;.router-link-active &#123; background-color: #f6f6f6;&#125;.navbar &#123; height: 50px; background-color: #303030;&#125;.content &#123; margin-top: 50px; padding-left: 210px;&#125;.sidebar &#123; background-color: #f5f5f5; border-right: 1px solid #eee; width: 200px;&#125;@media (min-width: 768px) &#123; .sidebar &#123; position: fixed; top: 51px; bottom: 0; left: 0; z-index: 1000; display: block; padding: 20px; overflow-x: hidden; overflow-y: auto; /* Scrollable contents if viewport is shorter than content. */ background-color: #f5f5f5; border-right: 1px solid #eee; &#125;&#125;&lt;/style&gt; 单文件书写组件的方式必须要配合webpack之类的工具才行，所以这里暂时不讲解如何做，后面到项目阶段的时候再详细讲解。不过你可以参考：Vue官网单文件组件 组件总结Vue的组件化还是做的比较彻底的。不像Angular1.0中的模块那么鸡肋。组件化确实让前端模块化开发更加容易实现，Vue的单文件开发组件的方式也是Vue的一大创新，也发非常好用。","categories":[{"name":"VueJS","slug":"VueJS","permalink":"http://yoursite.com/categories/VueJS/"}],"tags":[{"name":"Vuejs","slug":"Vuejs","permalink":"http://yoursite.com/tags/Vuejs/"},{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"},{"name":"Vue组件化","slug":"Vue组件化","permalink":"http://yoursite.com/tags/Vue组件化/"}]},{"title":"CSS3的介绍","slug":"css3","date":"2017-06-03T05:34:02.000Z","updated":"2017-06-03T05:36:16.000Z","comments":true,"path":"2017/06/03/css3/","link":"","permalink":"http://yoursite.com/2017/06/03/css3/","excerpt":"","text":"正文开始CSS3 摘要：直到今天，伴随着 Web2.0 技术的流行，以前的 CSS2 标准和相关技术似乎早已经不能够满足不了日益增长的开发需求：人们需要实现更加美观、用户体验更好的HTML界面。CSS3，这个新一代的标准由此诞生。CSS3为了满足现有的对于 Web UI 的开发需求，它提供了一系列强大的功能和新特性，如许多新的 CSS 属性（文字，布局，颜色等等），以及各种 CSS 特效，甚至还支持 CSS 动画、元素的变形。这些 CSS 新特性在现阶段来说都是非常强大和完善的，您只需要加入简单的的几行 CSS 代码便可以实现出一系列令人眼前一亮的炫酷效果，这比我们之前用 JavaScript 去模拟实现这样的效果要好得多，不仅降低了开发复杂程度，代码变得易维护，在性能上也得到突飞猛进的进步。下面将主要来介绍 CSS3 的新特性以及一些使用上的方法和技巧。 简介：CSS即层叠样式表（Cascading StyleSheet）。 在HTML网页制作过程中采用层叠样式表技术，可以有效地对HTMl页面的布局、颜色、背景、字体和其它效果实现更加精确的控制。 只要对相应的代码做一些简单的修改或添加，就可以使同一页面的不同区域，或者页数不同的网页的格式和外观。 CSS3是CSS技术的升级版本，CSS3语言开发是朝着模块化方向发展的。以前的CSS2规范作为一个模块实在是太庞大而且比较复杂，所以，把它拆解为一个个小的模块，更多新的模块也被同时加入进来。这些模块包括：超链接方式 、语言模块 、边框和背景 、文字特效、盒子模型、列表模块、、多栏布局等模块。 CSS3是在CSS的接触上增加了很多新的特性，而且CSS3与低版本的CSS并不冲突。 CSS3新特性涉及范围非常广泛，这里挑选一些被浏览器支持较为完美、更具实用性的几个新特性。 1.强大的CSS3选择器2.抛弃图片的视觉效果3.背景的变革4.盒模型变化5.阴影效果6.多列布局与弹性盒模型布局7.Web字体和Web Font图标8.颜色和透明度9.圆角与边框的新法10.盒容器的变形11.CSS3过渡与动画交互效果12.媒体特性与Responsive布局 使用CSS3有什么好处与CSS比起来，使用CSS3有什么好处呢？最明显的就是CSS3的使用能让页面看起来非常炫酷，而且操作手法简单，使网站设计更加具有美感，但是它的好处远远不止有这些。在绝大多数的情况下， 使用CSS3不仅有利于开发与维护，而且还能提高网站的整体性能。与此同时，CSS3的使用还可以增加网站的可读性、可访问性、可用性，使制作的网站能适配更多的设备，甚至还可以优化网站SEO操作，同时提升网站的搜索排名结果。下面介绍CSS3特有的好处。 1.减少网站的开发成本与维护成本2.很大程度的提高页面性能 CSS3的现状网页制作中使用CSS3会带来非常多的好处，目前国内外使用CSS3特性制作网站的案例越来越多，特别是一些优秀的个人站点和项目，更是将其使用得出神入化。 CSS3的未来CSS3技术无疑对Web前端开发带来质的进步。虽然目前CSS3还没有完全普及到各个浏览器，但对于我们积极地去学习和使用并不矛盾，学习和掌握CSS3必是大势所趋。CSS3将会是引导我们进入编写网页精彩世界的先驱技术。前端开发人员能够通过CSS3更轻松地创建功能强大、易于维护网站。随着旧版浏览器所占市场份额逐渐减少，学习CSS3技术将更有优势和价值。目前来说这是作为一位优秀前端开发人员所必须掌握的技术之一，也是前端开发人员的大势所趋。当然，如果想学习一门新技术不能盲目的跟风，需要理性思考，但是这种理性思考并不表示对新技术的畏畏缩缩，同时也应该知道学习新技术过程中可能遇到的风险和困难。只有这样，才能更好地学习和使用CSS3技术。 CSS3的兼容性问题幸运的是，CSS3特性大部分浏览器都已经有了很好的支持度。各大主流浏览器对CSS3的支持越来越完善，那个曾经让多少前端开发人员心碎的IE浏览器也开始慢慢使用CSS3标准行列。当然，即使CSS3标准制定完成，现代浏览器要普及到大部分用户也是一定是个相当漫长的过程。如果你现在就打算使用CSS3来美化你的站点，那么就有必要对各大主流浏览器对其新技术的支持情况有一个全面的了解。 CSS3在各个浏览器下需要添加私有前缀常用浏览器 内核 私有前缀Chrome webkit -weibkit-firefox moz -moz-opera(老版) o -o-IE ms -ms- 为什么会有私有前缀:Chrome低版本 为了早早的支持还没有发布正式版本的CSS3的属性 所以在属性前加了一个自己浏览器认识的标志 如何在工作学习中运用CSS31.统一环境 (chrome firefox)2.放下兼容性 (1.加私有前缀 2.去js中寻找方法) 结束语上面的内容介绍了什么是CSS3、CSS3的发展状况、新特性，以及浏览器对CSS3的支持情况；学习CSS3的好处有很多，它能让你始终处于web网页制作技术的前沿，增加你的职业技能和竞争力，还会帮助你缩短与顶级设计师或开发者的距离。","categories":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/categories/CSS3/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"}]},{"title":"前端构建工具gulp入门教程","slug":"前端构建工具gulp入门教程","date":"2017-04-26T15:42:26.000Z","updated":"2017-09-07T02:00:52.000Z","comments":true,"path":"2017/04/26/前端构建工具gulp入门教程/","link":"","permalink":"http://yoursite.com/2017/04/26/前端构建工具gulp入门教程/","excerpt":"","text":"正文部分第一步：安装Node&#160; &#160; &#160; &#160;首先，最基本也最重要的是，我们需要搭建node环境。访问 http://nodejs.org ，然后点击大大的绿色的 install 按钮，下载完成后直接运行程序，就一切准备就绪。 npm 会随着安装包一起安装，稍后会用到它 第二步：使用命令行&#160; &#160; &#160; &#160;也许现在你还不是很了解什么是命令行——OSX中的终端（Terminal），windows中的命令提示符（Command Prompt），但很快你就会知道。它看起来没那么简单，但一旦掌握了它的窍门，就可以很方便的执行很多命令行程序，比如Sass，Yeoman和Git等，这些都是非常有用的工具。 如果你很熟悉命令行，直接跳到步骤四。为了确保Node已经正确安装，我们执行几个简单的命令。 1node -v 回车（Enter），如果正确安装的话，你会看到所安装的Node的版本号，接下来看看npm。1npm -v 这同样能得到npm的版本号。 如果这两行命令没有得到返回，可能node就没有安装正确，尝试重启下命令行工具，如果还不行的话，只能回到第一步进行重装。 第三步：定位到项目&#160; &#160; &#160; &#160;现在，我们已经大致了解了命令行并且知道如何简单使用它，接下来只需要两个简单的命令就能定位到文件目录并看看目录里都有些什么文件。12cd 定位到目录ls 列出文件列表 &#160; &#160; &#160; &#160;建议多敲敲这两个命令，了解文件系统并知道文件都在哪里。习惯使用了这两个命令后，就要进入我们的项目目录，这个目录各不相同，举个例子，这是我进入我项目目录的命令： 1cd /Applications/XAMPP/xamppfiles/htdocs/my-project 成功进入项目目录后，我们开始安装gulp。 第四步：安装gulp&#160; &#160; &#160; &#160;我们已经知道如何使用命令行，现在尝试点新的东西，认识npm然后安装gulp。 &#160; &#160; &#160; &#160;NPM是基于命令行的node包管理工具，它可以将node的程序模块安装到项目中，在它的 官网 中可以查看和搜索所有可用的程序模块。 1sudo npm install -g gulp &#160; &#160; &#160; &#160;sudo是以管理员身份执行命令，一般会要求输入电脑密码npm是安装node模块的工具，执行install命令 &#160; &#160; &#160; &#160;-g表示在全局环境安装，以便任何项目都能使用它 &#160; &#160; &#160; &#160;最后，gulp是将要安装的node模块的名字运行时注意查看命令行有没有错误信息，安装完成后，你可以使用下面的命令查看gulp的版本号以确保gulp已经被正确安装。 1gulp -v 接下来，我们需要将gulp安装到项目本地 1npm install —-save-dev gulp &#160; &#160; &#160; &#160;这里，我们使用 —-save-dev 来更新package.json文件，更新 devDependencies 值，以表明项目需要依赖gulp。 &#160; &#160; &#160; &#160;Dependencies 可以向其他参与项目的人指明项目在开发环境和生产环境中的node模块依懒关系，想要更加深入的了解它可以看看 package.json文档 。 第五步：运行gulp&#160; &#160; &#160; &#160;安装好gulp后我们需要告诉它要为我们执行哪些任务，首先，我们自己需要弄清楚项目需要哪些任务。 检查Javascript编译Sass（或Less之类的）文件合并Javascript压缩并重命名合并后的Javascript安装依赖1npm install gulp-jshint gulp-sass gulp-concat gulp-uglify gulp-rename --save-dev &#160; &#160; &#160; &#160;提醒下，如果以上命令提示权限错误，需要添加 sudo 再次尝试。新建gulpfile文件 &#160; &#160; &#160; &#160;现在，组件都安装完毕，我们需要新建gulpfile文件以指定gulp需要为我们完成什么任务。 &#160; &#160; &#160; &#160;gulp只有五个方法： task ， run ， watch ， src ，和 dest ，在项目根目录新建一个js文件并命名为 gulpfile.js ，把下面的代码粘贴进去： gulpfile.js12345678910111213141516171819202122232425262728293031323334353637383940414243// 引入 gulpvar gulp = require('gulp'); // 引入组件var jshint = require('gulp-jshint');var sass = require('gulp-sass');var concat = require('gulp-concat');var uglify = require('gulp-uglify');var rename = require('gulp-rename');// 检查脚本gulp.task('lint', function() &#123; gulp.src('./js/*.js') .pipe(jshint()) .pipe(jshint.reporter('default'));&#125;);// 编译Sassgulp.task('sass', function() &#123; gulp.src('./scss/*.scss') .pipe(sass()) .pipe(gulp.dest('./css'));&#125;);// 合并，压缩文件gulp.task('scripts', function() &#123; gulp.src('./js/*.js') .pipe(concat('all.js')) .pipe(gulp.dest('./dist')) .pipe(rename('all.min.js')) .pipe(uglify()) .pipe(gulp.dest('./dist'));&#125;);// 默认任务gulp.task('default', function()&#123; gulp.run('lint', 'sass', 'scripts'); // 监听文件变化 gulp.watch('./js/*.js', function()&#123; gulp.run('lint', 'sass', 'scripts'); &#125;);&#125;); 分段解释代码。引入组件1234567var gulp = require('gulp'); var jshint = require('gulp-jshint');var sass = require('gulp-sass');var concat = require('gulp-concat');var uglify = require('gulp-uglify');var rename = require('gulp-rename'); &#160; &#160; &#160; &#160;这一步，我们引入了核心的gulp和其他依赖组件，接下来，分开创建lint, sass, scripts 和 default这四个不同的任务。 Lint任务12345gulp.task('lint', function() &#123; gulp.src('./js/*.js') .pipe(jshint()) .pipe(jshint.reporter('default'));&#125;); &#160; &#160; &#160; &#160;Link任务会检查 js/ 目录下得js文件有没有报错或警告。 Sass任务12345gulp.task('sass', function() &#123; gulp.src('./scss/*.scss') .pipe(sass()) .pipe(gulp.dest('./css'));&#125;); &#160; &#160; &#160; &#160;Sass任务会编译 scss/ 目录下的scss文件，并把编译完成的css文件保存到 /css 目录中。 Scripts 任务12345678gulp.task('scripts', function() &#123; gulp.src('./js/*.js') .pipe(concat('all.js')) .pipe(gulp.dest('./dist')) .pipe(rename('all.min.js')) .pipe(uglify()) .pipe(gulp.dest('./dist'));&#125;); &#160; &#160; &#160; &#160;scripts任务会合并 js/ 目录下得所有得js文件并输出到 dist/ 目录，然后gulp会重命名、压缩合并的文件，也输出到 dist/ 目录。 default任务1234gulp.task('default', function() &#123; //监视src下的文件如果发生改变，重新执行打包任务 gulp.watch('./src/**/*.*', ['lint', 'sass', 'scripts']);&#125;); &#160; &#160; &#160; &#160;这时，我们创建了一个基于其他任务的default任务。使用 .watch() 方法去监听指定目录的文件变化，当有文件变化时，会运行回调定义的其他任务。 现在，回到命令行，可以直接运行gulp任务了。 gulp这将执行定义的default任务，换言之，这和以下的命令式同一个意思 gulp default当然，我们可以运行在gulpfile.js中定义的任意任务，比如，现在运行sass任务： gulp sass(Kimi: 哇塞，酷比了哎~) 结束语现在已经做到了设置gulp任务然后运行他们，现在再回顾下之前学习的。 学习了安装Node环境学习了简单使用命令行学习了用命令行进入项目目录学习了使用npm和安装gulp学习了如何运行gulp任务另外，有一些参考资源供进一步学习：http://www.gulpjs.com.cn/","categories":[{"name":"构建工具","slug":"构建工具","permalink":"http://yoursite.com/categories/构建工具/"}],"tags":[{"name":"前端构建工具","slug":"前端构建工具","permalink":"http://yoursite.com/tags/前端构建工具/"},{"name":"打包压缩工具","slug":"打包压缩工具","permalink":"http://yoursite.com/tags/打包压缩工具/"},{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}]},{"title":"angularjs(四)","slug":"angular-4","date":"2017-04-25T05:17:02.000Z","updated":"2017-05-14T14:15:24.000Z","comments":true,"path":"2017/04/25/angular-4/","link":"","permalink":"http://yoursite.com/2017/04/25/angular-4/","excerpt":"","text":"正文开始过滤器 1.过滤器&#160; &#160; &#160; &#160;过滤器（filter）正如其名，作用就是接收一个输入，通过某个规则进行处理，然后返回处理后的结果。主要用在数据的格式化上，例如获取一个数组中的子集，对数组中的元素进行排序等。过滤器通常是伴随标记来使用的，将你model中的数据格式化为需要的格式。表单的控制功能主要涉及到数据验证以及表单控件的增强。ng内置了一些过滤器，它们是： currency(货币)、date(日期)、filter(子串匹配)、json(格式化json对象)、limitTo(限制个数)、lowercase(小写)、uppercase(大写)、number(数字)、orderBy(排序)。 过滤器使用方式&#160; &#160; &#160; &#160;总共九种。除此之外还可以自定义过滤器，这个就强大了，可以满足任何要求的数据处理。Filter还是很简单的，需要明白的是内置的filter如何使用，以及自己如何定义一个filter。 filter的两种使用方法：1. 在模板中使用filter我们可以直接在双括号中使用filter，跟在表达式后面用 | 分割，语法如下： 1&#123;&#123; expression | filter &#125;&#125; 也可以多个filter连用，上一个filter的输出将作为下一个filter的输入： 1&#123;&#123; expression | filter1 | filter2 | ... &#125;&#125; filter可以接收参数，参数用 : 进行分割，如下： 1&#123;&#123; expression | filter:argument1:argument2:... &#125;&#125; 除了对双括号中的数据进行格式化，我们还可以在指令中使用filter，例如先对数组array进行过滤处理，然后再循环输出： 1&lt;span ng-repeat=\"a in array | filter \"&gt; 2. 在controller和service中使用filter&#160; &#160; &#160; &#160;我们的js代码中也可以使用过滤器，方式就是我们熟悉的依赖注入，例如我要在controller中使用currency过滤器，只需将它注入到该controller中即可，代码如下： 123app.controller('testC',function($scope,currencyFilter)&#123; $scope.num = currencyFilter(123534); &#125; 在模板中使用就可以直接输出$123,534.00了！在服务中使用filter也是同样的道理。 &#160; &#160; &#160; &#160;如果你要在controller中使用多个filter，并不需要一个一个注入吗，ng提供了一个$filter服务可以来调用所需的filter，你只需注入一个$filter就够了，使用方法如下： 1234app.controller('testC',function($scope,$filter)&#123; $scope.num = $filter('currency')(123534); $scope.date = $filter('date')(new Date()); &#125; 可以达到同样的效果。好处是你可以方便使用不同的filter了。 3. ng的内置过滤器&#160; &#160; &#160; &#160;ng内置了九种过滤器，使用方法都非常简单，看文档即懂。不过为了以后不去翻它的文档，我在这里还是做一个详细的记录。&#160; &#160; &#160; &#160;currency(货币)、date(日期)、filter(子串匹配)、json(格式化json对象)、limitTo(限制个数)、lowercase(小写)、uppercase(大写)、number(数字)、orderBy(排序) 1. currency (货币处理)&#160; &#160; &#160; &#160;使用currency可以将数字格式化为货币，默认是美元符号，你可以自己传入所需的符号，例如我传入人民币： 1&#123;&#123;num | currency : '￥'&#125;&#125; 2. date (日期格式化)&#160; &#160; &#160; &#160;原生的js对日期的格式化能力有限，ng提供的date过滤器基本可以满足一般的格式化要求。用法如下： 1&#123;&#123;date | date : 'yyyy-MM-dd hh:mm:ss EEEE'&#125;&#125; &#160; &#160; &#160; &#160;参数用来指定所要的格式，y M d h m s E 分别表示 年 月 日 时 分 秒 星期，你可以自由组合它们。也可以使用不同的个数来限制格式化的位数。另外参数也可以使用特定的描述性字符串，例如“shortTime”将会把时间格式为12:05 pm这样的。ng提供了八种描述性的字符串，个人觉得这些有点多余，我完全可以根据自己的意愿组合出想要的格式，不愿意去记这么多单词~ 3. filter(匹配子串)&#160; &#160; &#160; &#160;这个名叫filter的filter。用来处理一个数组，然后可以过滤出含有某个子串的元素，作为一个子数组来返回。可以是字符串数组，也可以是对象数组。如果是对象数组，可以匹配属性的值。它接收一个参数，用来定义子串的匹配规则。下面举个例子说明一下参数的用法，我用现在特别火的几个孩子定义了一个数组： 123456789101112$scope.childrenArray = [ &#123;name:'kimi',age:3&#125;, &#123;name:'cindy',age:4&#125;, &#123;name:'anglar',age:4&#125;, &#123;name:'shitou',age:6&#125;, &#123;name:'tiantian',age:5&#125;]; $scope.func = function(e)&#123;return e.age&gt;4;&#125;&#123;&#123; childrenArray | filter : 'a' &#125;&#125; //匹配属性值中含有a的 &#123;&#123; childrenArray | filter : 4 &#125;&#125; //匹配属性值中含有4的 &#123;&#123; childrenArray | filter : &#123;name : 'i'&#125; &#125;&#125; //参数是对象，匹配name属性中含有i的 &#123;&#123;childrenArray | filter : func &#125;&#125; //参数是函数，指定返回age&gt;4的 4. json(格式化json对象)&#160; &#160; &#160; &#160;json过滤器可以把一个js对象格式化为json字符串，没有参数。这东西有什么用呢，我一般也不会在页面上输出一个json串啊，官网说它可以用来进行调试，嗯，是个不错的选择。或者，也可以用在js中使用，作用就和我们熟悉的JSON.stringify()一样。用法超级简单： 1&#123;&#123; jsonTest | json&#125;&#125; 5. limitTo(限制数组长度或字符串长度)&#160; &#160; &#160; &#160;limitTo过滤器用来截取数组或字符串，接收一个参数用来指定截取的长度，如果参数是负值，则从数组尾部开始截取。个人觉得这个filter有点鸡肋，首先只能从数组或字符串的开头/尾部进行截取，其次，js原生的函数就可以代替它了，看看怎么用吧： 1&#123;&#123; childrenArray | limitTo : 2 &#125;&#125; //将会显示数组中的前两项 6. lowercase(小写)&#160; &#160; &#160; &#160;把数据转化为全部小写。太简单了，不多解释。同样是很鸡肋的一个filter，没有参数，只能把整个字符串变为小写，不能指定字母。怎么用我都懒得写了。 7. uppercase(大写)同上。 8. number(格式化数字)&#160; &#160; &#160; &#160;number过滤器可以为一个数字加上千位分割，像这样，123,456,789。同时接收一个参数，可以指定float类型保留几位小数： 1&#123;&#123; num | number : 2 &#125;&#125; 9. orderBy(排序)&#160; &#160; &#160; &#160;orderBy过滤器可以将一个数组中的元素进行排序，接收一个参数来指定排序规则，参数可以是一个字符串，表示以该属性名称进行排序。可以是一个函数，定义排序属性。还可以是一个数组，表示依次按数组中的属性值进行排序（若按第一项比较的值相等，再按第二项比较），还是拿上面的孩子数组举例： 123&lt;div&gt;&#123;&#123; childrenArray | orderBy : 'age' &#125;&#125;&lt;/div&gt; //按age属性值进行排序，若是-age，则倒序&lt;div&gt;&#123;&#123; childrenArray | orderBy : orderFunc &#125;&#125;&lt;/div&gt; //按照函数的返回值进行排序&lt;div&gt;&#123;&#123; childrenArray | orderBy : ['age','name'] &#125;&#125;&lt;/div&gt; //如果age相同，按照name进行排序 内置的过滤器介绍 &#160; &#160; &#160; &#160;完了，写的我都快睡着了。。。正如你所看到的，ng内置的过滤器也并不是万能的，事实上好多都比较鸡肋。更个性化的需求就需要我们来定义自己的过滤器了，下面来看看如何自定义过滤器。 3.自定义过滤器及示例&#160; &#160; &#160; &#160;filter的自定义方式也很简单，使用module的filter方法，返回一个函数，该函数接收输入值，并返回处理后的结果。话不多说，我们来写一个看看。比如我需要一个过滤器，它可以返回一个数组中下标为奇数的元素，代码如下： 1234567891011app.filter('odditems',function()&#123; return function(inputArray)&#123; var array = []; for(var i=0;i&lt;inputArray.length;i++)&#123; if(i%2!==0)&#123; array.push(inputArray[i]); &#125; &#125; return array; &#125;&#125;); &#160; &#160; &#160; &#160;格式就是这样，你的处理逻辑就写在内部的那个闭包函数中。你也可以让自己的过滤器接收参数，参数就定义在return的那个函数中，作为第二个参数，或者更多个参数也可以。 &#160; &#160; &#160; &#160;格式就是这样，你的处理逻辑就写在内部的那个闭包函数中。你也可以让自己的过滤器接收参数，参数就定义在return的那个函数中，作为第二个参数，或者更多个参数也可以。自定义过滤器实例（例04）: 12345678910111213141516171819/* View html */First name：&lt;input ng-model=\"user.firstName\"/&gt;&lt;br/&gt;Last name：&lt;input ng-model=\"user.lastName\"/&gt; &lt;br/&gt;First name：&#123;&#123;user.firstName&#125;&#125; Last name：&#123;&#123;user.lastName&#125;&#125; &lt;br/&gt;Fullname：&#123;&#123;user | flFullname&#125;&#125;&lt;br/&gt;Fullname：&#123;&#123;user | flFullname:\"－\"&#125;&#125;&lt;br/&gt;Fullname：&#123;&#123;user | flFullname:\"•\" | uppercase &#125;&#125;/* Controller js */demoApp.filter(\"flFullname\", function() &#123; return function(user, sep) &#123; sep = sep || \" \"; user = user || &#123;&#125;; fullName = \"\"; if(user.firstName)&#123;fullName += user.firstName;&#125; if(user.lastName)&#123;fullName = fullName + sep + user.lastName;&#125; if(fullName &amp;&amp; fullName.length&gt;0)&#123;return fullName; &#125;else&#123;return \"\";&#125; &#125;;&#125;);","categories":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://yoursite.com/categories/AngularJS/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yoursite.com/tags/angularjs/"},{"name":"angular过滤器","slug":"angular过滤器","permalink":"http://yoursite.com/tags/angular过滤器/"}]},{"title":"angularjs(五)","slug":"angular-5","date":"2017-04-25T05:17:02.000Z","updated":"2017-05-14T14:15:20.000Z","comments":true,"path":"2017/04/25/angular-5/","link":"","permalink":"http://yoursite.com/2017/04/25/angular-5/","excerpt":"","text":"正文开始过滤器 指令(directive)&#160; &#160; &#160; &#160;通过使用模板，我们可以把model和controller中的数据组装起来呈现给浏览器，还可以通过数据绑定，实时更新视图，让我们的页面变成动态的。 模板中可以使用的东西包括以下四种： 指令(directive)：ng提供的或者自定义的标签和属性，用来增强HTML表现力； 标记(markup)：即双大括号，可将数据单向绑定到HTML中； 过滤器(filter)：用来格式化输出数据； 表单控制：用来增强表单的验证功能。 &#160; &#160; &#160; &#160;其中，指令无疑是使用量最大的，ng内置了很多指令用来控制模板，如ng-repeat，ng-class，也有很多指令来帮你完成业务逻辑，如ng-controller,ng-model。 指令的几种使用方式如下： 1234l 作为标签：&lt;my-dir&gt;&lt;/my-dir&gt;l 作为属性：&lt;span my-dir=\"exp\"&gt;&lt;/span&gt;l 作为注释：&lt;!-- directive: my-dir exp --&gt;l 作为类名：&lt;span class=\"my-dir: exp;\"&gt;&lt;/span&gt; 其实常用的就是作为标签和属性。 1.样式相关的指令&#160; &#160; &#160; &#160;既然模板就是普通的HTML，那我首要关心的就是样式的控制，元素的定位、字体、背景色等等如何可以灵活控制。下面来看看常用的样式控制指令。 1.1 ng-class&#160; &#160; &#160; &#160;ng-class用来给元素绑定类名，其表达式的返回值可以是以下三种： 类名字符串，可以用空格分割多个类名，如’redtext boldtext’；_ 类名数组，数组中的每一项都会层叠起来生效；_ 一个名值对应的map，其键值为类名，值为boolean类型，当值为true时，该类会被加在元素上。_ &#160; &#160; &#160; &#160;下面来看一个使用map的例子：ng-class测试红色 加粗 删除线 1map:&#123;redtext:&#123;&#123;red&#125;&#125;, boldtext:&#123;&#123;bold&#125;&#125;, striketext:&#123;&#123;strike&#125;&#125;&#125; &#160; &#160; &#160; &#160;如果你想拼接一个类名出来，可以使用插值表达式，如： 1 &lt;div class=”&#123;&#123;style&#125;&#125;text”&gt;字体样式测试&lt;/div&gt; 然后在controller中指定style的值： 1 $scope.style = ‘red’; &#160; &#160; &#160; &#160;注意我用了class而不是ng-class，这是不可以对换的，官方的文档也未做说明，姑且认为这是ng的语法规则吧。&#160; &#160; &#160; &#160;与ng-class相近的，ng还提供了ng-class-odd、ng-class-even两个指令，用来配合ng-repeat分别在奇数列和偶数列使用对应的类。这个用来在表格中实现隔行换色再方便不过了。 1.2 ng-style&#160; &#160; &#160; &#160;ng-style用来绑定元素的css样式，其表达式的返回值为一个js对象，键为css样式名，值为该样式对应的合法取值。用法比较简单：1&lt;div ng-style=\"&#123;color:'red'&#125;\"&gt;ng-style测试&lt;/div&gt; 12&lt;div ng-style=\"style\"&gt;ng-style测试&lt;/div&gt;$scope.style = &#123;color:'red'&#125;; 1.3 ng-show，ng-hide&#160; &#160; &#160; &#160;对于比较常用的元素显隐控制，ng也做了封装，ng-show和ng-hide的值为boolean类型的表达式，当值为true时，对应的show或hide生效。框架会用display:block和display:none来控制元素的显隐。 2.表单控件功能相关指令 对于常用的表单控件功能，ng也做了封装，方便灵活控制。 ng-checked控制radio和checkbox的选中状态 ng-selected控制下拉框的选中状态 ng-disabled控制失效状态 ng-multiple控制多选 ng-readonly控制只读状态 以上指令的取值均为boolean类型，当值为true时相关状态生效，道理比较简单就不多做解释。注意： 上面的这些只是单向绑定，即只是从数据到模板，不能反作用于数据。要双向绑定，还是要使用 ng-model 。 3.事件绑定相关指令&#160; &#160; &#160; &#160;事件绑定是javascrpt中比较重要的一部分内容，ng对此也做了详细的封装，正如我们之前使用过的ng-click一样，事件的指令如下： 12345678910- ng-click - ng-change - ng-dblclick - ng-mousedown - ng-mouseenter - ng-mouseleave - ng-mousemove - ng-mouseover - ng-mouseup - ng-submit &#160; &#160; &#160; &#160;事件绑定指令的取值为函数，并且需要加上括号，例如： 1&lt;select ng-change=”change($event)”&gt;&lt;/select&gt; 然后在controller中定义如下： 1234$scope.change = function($event)&#123; alert($event.target); //……………………&#125; &#160; &#160; &#160; &#160;在模板中可以用变量$event将事件对象传递到controller中。对于ng的这种设计，一些人有所质疑，视图与事件绑定混在一起到底好不好？我们不是要讲究视图与逻辑分离吗？如此一来，把事件的绑定又变回了内联的，岂不是历史的倒退。我也一样对此表示不解，因为不写onclick已经很多年。。。但既然已经存在了，我们不妨往合理的方向上想一想，或许ng的设计者压根就不想让模板成为单纯的视图层，本来就是想增强HTML，让它有一点业务能力。这么想的话似乎也能想通，好吧，先欺骗一下自己吧~ 特殊的ng-src和ng-href在说明这两个指令的特殊之前，需要先了解一下ng的启动及执行过程，如下图： 1) 浏览器加载静态HTML文件并解析为DOM；2) 浏览器加载angular.js文件；3) angular监听DOMContentLoaded 事件，监听到时开始启动；4) angular寻找ng-app指令，确定作用范围；5) 找到app中定义的Module使用$injector服务进行依赖注入；6) 根据$injector服务创建$compile服务用于编译；7) $compile服务编译DOM中的指令、过滤器等；8) 使用ng-init指令，将作用域中的变量进行替换；9) 最后生成了我们在最终视图。&#160; &#160; &#160; &#160;可以看到，ng框架是在DOMcontent加载完毕后才开始发挥作用。假如我们模板中有一张图片如下： 1 &lt;img src=\"http://m.cnblogs.com/142260/”&#123;&#123;imgUrl&#125;&#125;” /&gt; &#160; &#160; &#160; &#160;那么在页面开始加载到ng编译完成之前，页面上会一直显示一张错误的图片，因为路径{&nbsp;{imgUrl}&nbsp;}还未被替换。 &#160; &#160; &#160; &#160;为了避免这种情况，我们使用ng-src指令，这样在路径被正确得到之前就不会显示找不到图片。同理，h标签的href属性也需要换成ng-href，这样页面上就不会先出现一个地址错误的链接。 &#160; &#160; &#160; &#160;顺着这个思路再多想一点，我们在模板中使用{&nbsp;{}}显示数据时，在ng编译完成之前页面上岂不是会显示出大括号及里面的表达式？确实是这样。为了避免这个，ng中有一个与{&nbsp;{}}等同的指令:ng-bind，同样用于单向绑定，在页面刚加载的时候就不会显示出对用户无用的数据了。尽管这样你可能不但没舒心反而更纠结了，{&nbsp;{}}那么好用易理解，还不能用了不成？好消息是我们依然可以使用。因为我编写的是单页面应用，页面只会在加载index.html的时 &#160; &#160; &#160; &#160;候出这个问题，只需在index.html中的模板中换成ng-bind就行。其他的模板是我们动态加载的，就可以放心使用{&nbsp;{}}了。 4.自定义指令示例&#160; &#160; &#160; &#160;下面我们来解析下指令的例子。 首先，我们定义一个名为userInfo的指令： 1234567891011121314151617demoApp.directive('userInfo',function()&#123;return &#123; restrict : 'E', templateUrl : 'userInfoTemplate.html', replace : true, transclude : true, scope : &#123; mytitle : '=etitle' &#125;, link : function(scope,element,attrs)&#123; scope.showText = false; scope.toggleText = function()&#123; scope.showText = ! scope.showText; &#125; &#125; &#125;;&#125;) Restrict为’E’：用作标签； replace为true：用模板替换当前标签； transclude为true：将当前元素的内容转移到模板中； scope 为 {mytitle : ‘=etitle’}：定义一个名为mytitle的MODEL，其值指向当前元素的etitle属性；templateUrl为’userInfoTemplate.html’：模板内容为ng-template定义ID为userInfoTemplate.html的内容； link：指定所包含的行为。link属性值为一个函数,这个函数有五个参数:scope,iEle,iAttrs,ctrl,linker userInfoTemplate.html模板为： 12345678910&lt;script type=\"text/ng-template\" id=\"userInfoTemplate.html\"&gt; &lt;div class=\"mybox\"&gt; &lt;div class=\"mytitle\" style=\"cursor: pointer;\" ng-click=\"toggleText()\"&gt; &#123; &#123;mytitle&#125; &#125; &lt;/div&gt; &lt;div ng-transclude ng-show=\"showText\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/script&gt; 将当前元素的内容添加到有ng-transclude属性的这个DIV下，默认是隐藏的。 Controller信息： 12345678demoApp.controller(\"test7Controller\", function($scope)&#123; $scope.title = '个人简介'; $scope.text = '大家好，我正在研究AngularJs，欢迎大家与我交流。'; $scope.updateInfo = function ()&#123; $scope.title = '个人信息'; $scope.text = '大家好，今天天气真好！'; &#125;&#125;); 指令使用方式（View信息）为： 1&lt;user-info etitle=\"title\"&gt;&#123; &#123;text&#125; &#125;&lt;/user-info&gt; Etitle指向Controller中的$scope.title。注意命名方式：指令名为userInfo，对应的标签为user-info。 总结指令是angular里面核心的功能，日常的学习和开发中也是使用不同指令去完成各种不同的需求，尤其自定义指令尤使用的频率极高，应该好好的掌握！","categories":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://yoursite.com/categories/AngularJS/"}],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"http://yoursite.com/tags/angularjs/"},{"name":"前端框架，angular指令","slug":"前端框架，angular指令","permalink":"http://yoursite.com/tags/前端框架，angular指令/"}]},{"title":"angular(六)","slug":"angular_6","date":"2017-04-25T05:17:02.000Z","updated":"2017-05-14T14:15:46.000Z","comments":true,"path":"2017/04/25/angular_6/","link":"","permalink":"http://yoursite.com/2017/04/25/angular_6/","excerpt":"","text":"正文开始服务 服务（service）服务介绍&#160; &#160; &#160; &#160;服务这个概念其实并不陌生，在其他语言中如Java便有这样的概念，其作用就是对外提供某个特定的功能，如消息服务，文件压缩服务等，是一个独立的模块。ng的服务是这样定义的： Angular services are singletons objects or functions that carry out specific tasks common to web apps. 它是一个单例对象或函数，对外提供特定的功能。首先是一个单例，即无论这个服务被注入到任何地方，对象始终只有一个实例。其次这与我们自己定义一个function然后在其他地方调用不同，因为服务被定义在一个模块中，所以其使用范围是可以被我们管理的。ng的避免全局变量污染意识非常强。 &#160; &#160; &#160; &#160;ng提供了很多内置的服务，可以到API中查看[http://docs.angularjs.org/api/。]知道了概念，我们来拉一个service出来溜溜，看看到底是个什么用法。 &#160; &#160; &#160; &#160;我们在controller中直接声明$location服务，这依靠ng的依赖注入机制。$location提供地址栏相关的服务，我们在此只是简单的获取当前的地址。 &#160; &#160; &#160; &#160;服务的使用是如此简单，我们可以把服务注入到controller、指令或者是其他服务中。 自定义服务&#160; &#160; &#160; &#160;如同指令一样，系统内置的服务以$开头，我们也可以自己定义一个服务。定义服务的方式有如下几种： 使用系统内置的$provide服务； 使用Module的factory方法； 使用Module的service方法。 &#160; &#160; &#160; &#160;下面通过一个小例子来分别试验一下。我们定义一个名为remoteData服务，它可以从远程获取数据，这也是我们在程序中经常使用的功能。不过我这里没有远程服务器，就写死一点数据模拟一下。//使用$provide来定义 1234567891011121314151617//使用$provide来定义var app = angular.module('MyApp', [], function($provide) &#123; $provide.factory('remoteData', function() &#123; var data = &#123;name:'n',value:'v'&#125;; return data; &#125;);&#125;);//使用factory方法app.factory('remoteData',function()&#123; var data = &#123;name:'n',value:'v'&#125;; return data;&#125;);//使用service方法app.service('remoteData',function()&#123; this.name = 'n'; this.value = 'v';&#125;); &#160; &#160; &#160; &#160;Module的factory和$provide的factory方法是一模一样的，从官网文档看它们其实就是一回事。至于Module内部是如何调用的，我此处并不打算深究，我只要知道怎么用就好了。 &#160; &#160; &#160; &#160;再看Module的service方法，它没有return任何东西，是因为service方法本身返回一个构造器，系统会自动使用new关键字来创建出一个对象。所以我们看到在构造器函数内可以使用this，这样调用该服务的地方便可以直接通过remoteData.name来访问数据了。 管理服务的依赖关系&#160; &#160; &#160; &#160;服务与服务中间可以有依赖关系，例如我们这里定义一个名为validate的服务，它的作用是验证数据是否合法，它需要依赖我们从远程获取数据的服务remoteData。代码如下： &#160; &#160; &#160; &#160;在factory的参数中，我们可以直接传入服务remoteData，ng的依赖注入机制便帮我们做好了其他工作。不过一定要保证这个参数的名称与服务名称一致，ng是根据名称来识别的。若参数的名次与服务名称不一致，你就必须显示的声明一下，方式如下： 1234567 app.factory('validate',['remoteData',function(remoteDataService)&#123; return function()&#123; if(remoteDataService.name=='n')&#123; alert('验证通过'); &#125; &#125;;&#125;]); &#160; &#160; &#160; &#160;我们在controller中注入服务也是同样的道理，使用的名称需要与服务名称一致才可以正确注入。否则，你必须使用$inject来手动指定注入的服务。比如： 123456 function testC(scope,rd)&#123; scope.getData = function()&#123; alert('name：'+rd.name+' value：'+rd.value); &#125;&#125;testC.$inject = ['$scope','remoteData']; &#160; &#160; &#160; &#160;在controller中注入服务，也可以在定义controller时使用数组作为第二个参数，在此处把服务注入进去，这样在函数体中使用不一致的服务名称也是可以的，不过要确保注入的顺序是一致的，如： 12345app.controller('testC',['$scope','remoteData',function($scope,rd)&#123; $scope.getData = function()&#123; alert('name：'+rd.name+' value：'+rd.value); &#125;&#125;]); 自定义服务示例&#160; &#160; &#160; &#160;接下来让我们看下例子（例08 自定义服务）代码，自定义userService服务： 12345678910111213141516171819202122demoApp.factory('userService', ['$http', function($http) &#123;var doGetUser = function(userId, path) &#123;//return $http(&#123;//method: 'JSONP',//url: path//&#125;);/*手动指定数据*/var data = &#123;userId:\"woshishui\",userName:\"我是谁\",userInfo:\"我是谁！我是谁！\"&#125;;;if(userId=='zhangsan')&#123;data = &#123;userId:\"zhangsan\",userName:\"张三\",userInfo:\"我是张三，我为自己\"&#125;;&#125;else if(userId=='lisi')&#123;data = &#123;userId:\"lisi\",userName:\"李四\",userInfo:\"我是李四，我为卿狂！\"&#125;;&#125;return data;&#125;return &#123;/*userService对外暴露的函数，可有多个*/getUser: function(userId) &#123; return doGetUser(userId, '../xxx/xxx.action'); &#125; &#125;;&#125;]); &#160; &#160; &#160; &#160;我们创建了一个只有一个方法的userService，getUser为这个服务从后台获取用户信息的函数，并且对外暴露。当然，由于这是一个静态的例子，无法访问后台，那么我们便制定其返回的数据。 &#160; &#160; &#160; &#160;然后我们把这个服务添加到我们的controller中。我们建立一个controller并加载（或者注入）userService作为运行时依赖，我们把service的名字作为参数传递给controller 函数： 12345678910111213141516171819202122demoApp.controller(\"test8Controller\", function($scope,userService)&#123;/*文章信息*/$scope.articles = [&#123;title : \"爱飞像风\",userId : \"zhangsan\",userName : \"张三\"&#125;,&#123;title : \"无法停止的雨\",userId : \"lisi\",userName : \"李四\"&#125;];$scope.showUserInfo = false;//显示作者详细信息开关$scope.currentUser = &#123;&#125;; //当前选中的作者$scope.getUserInfo = function(userId)&#123;$scope.currentUser = userService.getUser(userId);//调用 userService的getUser函数$scope.showUserInfo = true;setTimeout(function()&#123;//定时器：隐藏作者详细信息$scope.showUserInfo = false;&#125;,3000);&#125;&#125;); &#160; &#160; &#160; &#160;我们的userService注入到我们的test8Controller后，我们就可以像使用其他服务（我们前面提到的$http服务）一样的使用userService了。 相关的HTML代码如下： 123456789101112131415/* View HTML*/&lt;tr ng-repeat=\"article_ in articles\"&gt;&lt;td&gt;&#123;&#123;article_.title&#125;&#125;&lt;/td&gt;&lt;td&gt;&lt;a href=\"javascript:void(0);\" target=\"_blank\" rel=\"nofollow\"&gt;&lt;/td&gt;&lt;/tr&gt;......&lt;div ng-show=\"showUserInfo\"&gt;用户ID：&#123;&#123;currentUser.userId&#125;&#125;&lt;br/&gt;用户名：&#123;&#123;currentUser.userName&#125;&#125;&lt;br/&gt;用户简介：&#123;&#123;currentUser.userInfo&#125;&#125;&lt;br/&gt;&lt;/div&gt;","categories":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://yoursite.com/categories/AngularJS/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yoursite.com/tags/angularjs/"},{"name":"angular服务","slug":"angular服务","permalink":"http://yoursite.com/tags/angular服务/"}]},{"title":"angular(八)","slug":"angular_8","date":"2017-04-25T05:17:02.000Z","updated":"2017-05-14T14:15:38.000Z","comments":true,"path":"2017/04/25/angular_8/","link":"","permalink":"http://yoursite.com/2017/04/25/angular_8/","excerpt":"","text":"正文开始路由DI 路由路由介绍&#160; &#160; &#160; &#160;在谈路由机制前有必要先提一下现在比较流行的单页面应用，就是所谓的single page APP。为了实现无刷新的视图切换，我们通常会用ajax请求从后台取数据，然后套上HTML模板渲染在页面上，然而ajax的一个致命缺点就是导致浏览器后退按钮失效，尽管我们可以在页面上放一个大大的返回按钮，让用户点击返回来导航，但总是无法避免用户习惯性的点后退。解决此问题的一个方法是使用hash，监听hashchange事件来进行视图切换，另一个方法是用HTML5的history API，通过pushState()记录操作历史，监听popstate事件来进行视图切换，也有人把这叫pjax技术。基本流程如下： &#160; &#160; &#160; &#160;如此一来，便形成了通过地址栏进行导航的深度链接（deeplinking ），也就是我们所需要的路由机制。通过路由机制，一个单页应用的各个视图就可以很好的组织起来了。 ngRoute内容&#160; &#160; &#160; &#160;ng的路由机制是靠ngRoute提供的，通过hash和history两种方式实现了路由，可以检测浏览器是否支持history来灵活调用相应的方式。ng的路由(ngRoute)是一个单独的模块，包含以下内容： 服务$routeProvider用来定义一个路由表，即地址栏与视图模板的映射 服务$routeParams保存了地址栏中的参数，例如 1&#123;id : 1, name : 'tom'&#125; 服务$route完成路由匹配，并且提供路由相关的属性访问及事件，如访问当前路由对应的controller 指令ngView用来在主视图中指定加载子视图的区域 以上内容再加上$location服务，我们就可以实现一个单页面应用了。下面来看一下具体如何使用这些内容。 ng的路由机制第一步：引入文件和依赖&#160; &#160; &#160; &#160;ngRoute模块包含在一个单独的文件中，所以第一步需要在页面上引入这个文件，如下： 12&lt;script src=\"http://code.angularjs.org/1.2.8/angular.min.js\" rel=\"nofollow\"/&gt;&lt;script src=\"http://code.angularjs.org/1.2.8/angular-route.min.js\" rel=\"nofollow\"/&gt; &#160; &#160; &#160; &#160;光引入还不够，我们还需在模块声明中注入对ngRoute的依赖，如下： 1var app = angular.module('MyApp', ['ngRoute']); &#160; &#160; &#160; &#160;完成了这些，我们就可以在模板或是controller中使用上面的服务和指令了。下面我们需要定义一个路由表。 第二步：定义路由表&#160; &#160; &#160; &#160;$routeProvider提供了定义路由表的服务，它有两个核心方法，when(path,route)和otherwise(params)，先看一下核心中的核心when(path,route)方法。&#160; &#160; &#160; &#160;when(path,route)方法接收两个参数，path是一个string类型，表示该条路由规则所匹配的路径，它将与地址栏的内容($location.path)值进行匹配。如果需要匹配参数，可以在path中使用冒号加名称的方式，如：path为/show/:name，如果地址栏是/show/tom，那么参数name和所对应的值tom便会被保存在$routeParams中，像这样：{name : tom}。我们也可以用*进行模糊匹配，如：/show*/:name将匹配/showInfo/tom。 &#160; &#160; &#160; &#160;route参数是一个object，用来指定当path匹配后所需的一系列配置项，包括以下内容： controller //function或string类型。在当前模板上执行的controller函数，生成新的scope； controllerAs //string类型，为controller指定别名； template //string或function类型，视图z所用的模板，这部分内容将被ngView引用； templateUrl //string或function类型，当视图模板为单独的html文件或是使用了&lt;script type=&quot;text/ng-template&quot;&gt;定义模板时使用； resolve //指定当前controller所依赖的其他模块； redirectTo //重定向的地址。 最简单情况，我们定义一个html文件为模板，并初始化一个指定的controller：12345678910function emailRouteConfig($routeProvider)&#123; $routeProvider.when('/show', &#123; controller: ShowController, templateUrl: 'show.html' &#125;). when('/put/:name',&#123; controller: PutController, templateUrl: 'put.html' &#125;)&#125;; &#160; &#160; &#160; &#160;otherwise(params)方法对应路径匹配不到时的情况，这时候我们可以配置一个redirectTo参数，让它重定向到404页面或者是首页。 第三步：在主视图模板中指定加载子视图的位置&#160; &#160; &#160; &#160;我们的单页面程序都是局部刷新的，那这个“局部”是哪里呢，这就轮到ngView出马了，只需在模板中简单的使用此指令，在哪里用，哪里就是“局部”。例如：&lt;div ng-view&gt;&lt;/div&gt; 或：&lt;ng-view&gt;&lt;/ng-view&gt; &#160; &#160; &#160; &#160;我们的子视图将会在此处被引入进来。完成这三步后，你的程序的路由就配置好了。 路由示例&#160; &#160; &#160; &#160;下面我们将用一个例子（例09）来说明路由的使用方式及步骤： 1.为demoApp添加一个路由，代码如下： 1234567891011demoApp.config(['$routeProvider',function($routeProvider) &#123; $routeProvider.when('/list', &#123; templateUrl: 'route/list.html', controller: 'routeListController'&#125;).when('/list/:id', &#123; templateUrl: 'route/detail.html', controller: 'routeDetailController' &#125;).otherwise(&#123; redirectTo: '/list' &#125;); &#125;]); /list 对应为：route/list.html页面，显示用户列表；/list/:id对应于route/detail.html页面，显示用户详细信息。 2.为list.html和detail.html分别声明Controller：routeListController和routeDetailController。123456789demoApp.controller('routeListController',function($scope) &#123; $scope.users = [&#123;userId:\"zhangsan\",userName:\"张三\",userInfo:\"我是张三，我为自己带盐！\"&#125;,&#123;userId:\"lisi\",userName:\"李四\",userInfo:\"我是李四，我为卿狂！\"&#125;,&#123;userId:\"woshishui\",userName:\"我是谁\",userInfo:\"我是谁！我是谁！我是谁！\"&#125;]; &#125;); demoApp.controller('routeDetailController',function($scope, $routeParams, userService) &#123; $scope.userDetail = userService.getUser($routeParams.id);&#125;); routeDetailController中如上面提到的一样，注入了userService服务，在这里直接拿来用。 3.创建list.html和detail.html页面，代码如下：12345678910111213141516171819&lt;hr/&gt; &lt;h3&gt;Route : List.html（用户列表页面）&lt;/h3&gt; &lt;ul&gt; &lt;li ng-repeat=\"user in users\"&gt; &lt;a href=\"http://m.cnblogs.com/142260/3817063.html?full=1#/list/&#123;&#123; user.userId &#125;&#125;\" target=\"_blank\" rel=\"nofollow\"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;hr/&gt;&lt;h3&gt;Route : detail.html（用户详细信息页面）&lt;/h3&gt; &lt;h3&gt;用户名：&lt;span style=\"color: red;\"&gt;&#123;&#123;userDetail.userName&#125;&#125;&lt;/span&gt;&lt;/h3&gt;&lt;div&gt;&lt;span&gt;用户ID：&#123;&#123;userDetail.userId&#125;&#125;&lt;/span&gt;&lt;span&gt;用户名：&#123;&#123;userDetail.userName&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;用户简介：&lt;span&gt;&#123;&#123;userDetail.userInfo&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;a href=\"http://m.cnblogs.com/142260/3817063.html?full=1#/list\" target=\"_blank\" rel=\"nofollow\"&gt;返回&lt;/a&gt; &lt;/div&gt; 路由局部刷新位置： 12&lt;h1&gt;AngularJS路由（Route） 示例&lt;/h1&gt; &lt;div ng-view&gt;&lt;/div&gt;","categories":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://yoursite.com/categories/AngularJS/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yoursite.com/tags/angularjs/"},{"name":"angular路由","slug":"angular路由","permalink":"http://yoursite.com/tags/angular路由/"}]},{"title":"AJAX","slug":"AJAX","date":"2017-04-25T05:17:02.000Z","updated":"2017-09-07T02:00:16.000Z","comments":true,"path":"2017/04/25/AJAX/","link":"","permalink":"http://yoursite.com/2017/04/25/AJAX/","excerpt":"","text":"正文开始Ajax ajax简介&#160; &#160; &#160; &#160;AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。Ajax不是一种新的编程语言，而是使用现有标准的新方法。AJAX可以在不重新加载整个页面的情况下，与服务器交换数据。这种异步交互的方式，使用户单击后，不必刷新页面也能获取新数据。使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。 Ajax包括. XHTML和CSS 使用文档对象模型(Document Object Model)作动态显示和交互 使用XML和XSLT做数据交互和操作 使用XMLHttpRequest进行异步数据接收 利用AJAX可以做： 注册时，输入用户名自动检测用户是否已经存在。 登陆时，提示用户名密码错误 删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据- 行也删除。 ajax伪造&#160; &#160; &#160; &#160;iframe就是我们常用的iframe标签:&lt;iframe&gt;。iframe标签是框架的一种形式，也比较常用到，iframe一般用来包含别的页面，例如我们可以在我们自己的网站页面加载别人网站或者本站其他页面的内容。iframe标签的最大作用就是让页面变得美观。iframe标签的用法有很多，主要区别在于对iframe标签定义的形式不同，例如定义iframe的长宽高。因此，iframe标签具有局部加载内容的特性，所以可以使用其来伪造Ajax请求。 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;伪造AJAX&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;请输入要加载的地址：&lt;span id=\"currentTime\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt; &lt;input id=\"url\" type=\"text\" /&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"LoadPage();\"&gt; &lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;加载页面位置：&lt;/h3&gt; &lt;iframe id=\"iframePosition\" style=\"width: 100%;height: 500px;\"&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; window.onload= function()&#123; var myDate = new Date(); document.getElementById('currentTime').innerText = myDate.getTime(); &#125;; function LoadPage()&#123; var targetUrl = document.getElementById('url').value; document.getElementById(\"iframePosition\").src = targetUrl; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; &#160; &#160; &#160; &#160;原理是这样的，设置一个提交按钮，再设置一个输入框，当我们输入一个网址的时候，在当前的页面加载输入网址的页面信息，呈现在iframe框里，这样就能做到不刷新URL来提交不同的信息。 原生ajaxAjax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。 XMLHttpRequest对象Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。XHR的主要方法有： 12345678910111213141516171819202122232425262728293031321. void open(String method,String url,Boolen async) 用于创建请求 参数： method： 请求方式（字符串类型），如：POST、GET、DELETE... url： 要请求的地址（字符串类型） async： 是否异步（布尔类型） 2. void send(String body) 用于发送请求 参数： body： 要发送的数据（字符串类型） 3. void setRequestHeader(String header,String value) 用于设置请求头 参数： header： 请求头的key（字符串类型） vlaue： 请求头的value（字符串类型） 4. String getAllResponseHeaders() 获取所有响应头 返回值： 响应头数据（字符串类型） 5. String getResponseHeader(String header) 获取响应头中指定header的值 参数： header： 响应头的key（字符串类型） 返回值： 响应头中指定的header对应的值 6. void abort() 终止请求 XHR的主要属性有： 12345678910111213141516171819201. Number readyState 状态值（整数），可以确定请求/响应过程的当前活动阶段0：未初始化。未调用open()方法1：启动。已经调用open()方法，未调用send()方法2：发送。已经调用send()方法，未接收到响应3：接收。已经接收到部分数据4：完成。已经接收到全部数据，可以在客户端使用2. Function onreadystatechange 当readyState的值改变时自动触发执行其对应的函数（回调函数）3. String responseText 作为响应主体被返回的文本（字符串类型）4. XmlDocument responseXML 服务器返回的数据（Xml对象） 5. Number states 状态码（整数），如：200、404... 6. String statesText 状态文本（字符串），如：OK、NotFound... get请求GET用于向服务器查询某些信息： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;XMLHttpRequest - Ajax请求&lt;/h1&gt; &lt;input type=\"button\" onclick=\"XmlGetRequest();\" value=\"Get发送请求\" /&gt; &lt;script src=\"/statics/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; function GetXHR()&#123; var xhr = null; if(XMLHttpRequest)&#123; xhr = new XMLHttpRequest(); &#125;else&#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; return xhr; &#125; function XmlGetRequest()&#123; var xhr = GetXHR(); // 定义回调函数 xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; // 已经接收到全部响应数据，执行以下操作 var data = xhr.responseText; console.log(data); &#125; &#125;; // 指定连接方式和地址----文件方式 xhr.open('get', \"/test/\", true); // 发送请求 xhr.send(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; post请求POST请求用于向服务器发送应该被保存的数据。POST请求的主体可以包含非常多的数据，而且格式不限。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;POST&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;XMLHttpRequest - Ajax请求&lt;/h1&gt; &lt;input type=\"button\" onclick=\"XmlPostRequest();\" value=\"Post发送请求\" /&gt; &lt;script src=\"/statics/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; function GetXHR()&#123; var xhr = null; if(XMLHttpRequest)&#123; xhr = new XMLHttpRequest(); &#125;else&#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; return xhr; &#125; function XmlPostRequest()&#123; var xhr = GetXHR(); // 定义回调函数 xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; // 已经接收到全部响应数据，执行以下操作 var data = xhr.responseText; console.log(data); &#125; &#125;; // 指定连接方式和地址----文件方式 xhr.open('POST', \"/test/\", true); // 设置请求头 xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset-UTF-8'); // 发送请求 xhr.send('n1=1;n2=2;'); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jquery ajaxjQuery 提供多个与 AJAX 有关的方法。&#160; &#160; &#160; &#160;通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON - 同时您能够把这些外部数据直接载入网页的被选元素中。 jQuery 不是生产者，而是大自然搬运工。 jQuery Ajax本质 XMLHttpRequest 或 ActiveXObject 注：2.+版本不再支持IE9以下的浏览器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748491. jQuery.get(...) 所有参数： url: 待载入页面的URL地址 data: 待发送 Key/value 参数。 success: 载入成功时回调函数。 dataType: 返回内容格式，xml, json, script, text, html2.jQuery.post(...) 所有参数： url: 待载入页面的URL地址 data: 待发送 Key/value 参数 success: 载入成功时回调函数 dataType: 返回内容格式，xml, json, script, text, html3.jQuery.getJSON(...) 所有参数： url: 待载入页面的URL地址 data: 待发送 Key/value 参数。 success: 载入成功时回调函数。4.jQuery.getScript(...) 所有参数： url: 待载入页面的URL地址 data: 待发送 Key/value 参数。 success: 载入成功时回调函数。5.jQuery.ajax(...) 部分参数： url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: \"application/x-www-form-urlencoded; charset=UTF-8\") async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端课接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 \"xml\": 将服务器端返回的内容转换成xml格式 \"text\": 将服务器端返回的内容转换成普通文本格式 \"html\": 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 \"script\": 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 \"json\": 将服务器端返回的内容转换成相应的JavaScript对象 \"jsonp\": JSONP 格式使用 JSONP 形式调用函数时，如 \"myurl?callback=?\" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数方法列表 写一个最简单的例子: 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; &lt;input type=\"button\" onclick=\"XmlSendRequest();\" value='Ajax请求' /&gt; &lt;/p&gt; &lt;script type=\"text/javascript\" src=\"jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; function JXmlSendRequest()&#123; $.ajax(&#123; url: \"http://c2.com:8000/test/\", // 访问url地址 type: 'GET', // get方式提交 dataType: 'text', // 数据类型 success: function(data, statusText, xmlHttpRequest)&#123; // 成功后返回的结果 console.log(data); &#125; &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 跨域ajax&#160; &#160; &#160; &#160;由于浏览器存在同源策略机制，同源策略阻止从一个源加载的文档或脚本获取或设置另一个源加载的文档的属性。所以ajax本身是不可以跨域的，通过产生一个script标签来实现跨域。因为script标签的src属性是没有跨域的限制的。浏览器同源策略并不是对所有的请求均制约： 制约： XmlHttpRequest 不制约： img、iframe、script等具有src属性的标签 注:自己模拟跨域，需要现在自己电脑的host文件里面添加两条域名，我这里添加的是bd.com和ky.com这两个域名 一、JSONP实现跨域请求JSONP是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问。jsonp只能通过get方式进行跨域请求 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"Ajax\" onclick=\"DoAjax();\"/&gt; &lt;input type=\"button\" value=\"JsonpAjax\" onclick=\"JsonpAjax();\"/&gt; &lt;script src=\"/statics/jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script src=\"http://aylin.com:8002/statics/jquery.cookie.js\"&gt;&lt;/script&gt; &lt;script&gt; function func(arg) &#123; console.log(arg); // 输出结果就是python代码给传过来的列表[11,22,33,] &#125; function DoAjax() &#123; $.ajax(&#123; url: 'http://org/index', type: 'POST', data: &#123;'k1': 'v1'&#125;, success: function (arg) &#123; console.log(arg); &#125; &#125;); &#125; function JsonpAjax() &#123;// var tag = document.createElement('script');// tag.src = \"http://alex.com:8002/index\";// document.head.appendChild(tag);// document.head.removeChild(tag); $.ajax(&#123; url: \"http://org/index\", dataType: 'jsonp', jsonpCallBack: 'func' // 对端给返回函数名，函数接收的参数是内容 &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在这里jsonp就采用script标签的src来进行跨域请求的 CORS&#160; &#160; &#160; &#160;上面那种方法说到浏览器的同源策略导致ajax无法进行跨域传输，那么这种方法就可以突破浏览器限制来进行传输。当数据发送给对方域名的时候，对方已经收到，但是在返回的时候被浏览器给阻挡，我们可以写一串类似于身份证的字符串，通过浏览器的预检，从而达到数据的传输。这方面分为简单请求和非简单请求 12345678910111213条件： 1、请求方式：HEAD、GET、POST 2、请求头信息： Accept Accept-Language Content-Language Last-Event-ID Content-Type 对应的值是以下三个中的任意一个 application/x-www-form-urlencoded multipart/form-data text/plain 注意：同时满足以上两个条件时，则是简单请求，否则为复杂请求 &#160; &#160; &#160; &#160;简单请求只一次请求，而复杂请求是两次请求，在发送数据之前会先发一次请求用于做“预检”，只有“预检”通过后才再发送一次请求用于数据传输。 基于cors实现AJAX请求:1.支持跨域,简单请求服务器设置响应头：Access-Control-Allow-Origin = ‘域名’ 或 ‘*’ 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; &lt;input type=\"submit\" onclick=\"XmlSendRequest();\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=\"submit\" onclick=\"JqSendRequest();\" /&gt; &lt;/p&gt; &lt;script type=\"text/javascript\" src=\"jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; function XmlSendRequest()&#123; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4) &#123; var result = xhr.responseText; console.log(result); &#125; &#125;; xhr.open('GET', \"http://c2.com:8000/test/\", true); xhr.send(); &#125; function JqSendRequest()&#123; $.ajax(&#123; url: \"http://c2.com:8000/test/\", type: 'GET', dataType: 'text', success: function(data, statusText, xmlHttpRequest)&#123; console.log(data); &#125; &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后台代码设置为： 1234class MainHandler(tornado.web.RequestHandler): def get(self): self.set_header('Access-Control-Allow-Origin', \"http://www.xxx.com\") self.write('&#123;\"status\": true, \"data\": \"seven\"&#125;') 2.支持跨域,复杂请求由于复杂请求时，首先会发送“预检”请求，如果“预检”成功，则发送真实数据。 “预检”请求时，允许请求方式则需服务器设置响应头：Access-Control-Request-Method “预检”请求时，允许请求头则需服务器设置响应头：Access-Control-Request-Headers “预检”缓存时间，服务器设置响应头：Access-Control-Max-Age html代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; &lt;input type=\"submit\" onclick=\"XmlSendRequest();\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=\"submit\" onclick=\"JqSendRequest();\" /&gt; &lt;/p&gt; &lt;script type=\"text/javascript\" src=\"jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; function XmlSendRequest()&#123; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4) &#123; var result = xhr.responseText; console.log(result); &#125; &#125;; xhr.open('PUT', \"http://aylin.com:8000/test/\", true); xhr.setRequestHeader('k1', 'v1'); xhr.send(); &#125; function JqSendRequest()&#123; $.ajax(&#123; url: \"http://aylin.com:8000/test/\", type: 'PUT', dataType: 'text', headers: &#123;'k1': 'v1'&#125;, success: function(data, statusText, xmlHttpRequest)&#123; console.log(data); &#125; &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后台代码 12345678910111213class MainHandler(tornado.web.RequestHandler): def put(self): self.set_header('Access-Control-Allow-Origin', \"http://www.xxx.com\") self.write('&#123;\"status\": true, \"data\": \"seven\"&#125;') def options(self, *args, **kwargs): self.set_header('Access-Control-Allow-Origin', \"http://www.xxx.com\") self.set_header('Access-Control-Allow-Headers', \"k1,k2\") self.set_header('Access-Control-Allow-Methods', \"PUT,DELETE\") self.set_header('Access-Control-Max-Age', 10)tornado 跨域传输cookie &#160; &#160; &#160; &#160;在跨域请求中，默认情况下，HTTP Authentication信息，Cookie头以及用户的SSL证书无论在预检请求中或是在实际请求都是不会被发送。如果想要发送： 浏览器端：XMLHttpRequest的withCredentials为true 服务器端：Access-Control-Allow-Credentials为true 注意：服务器端响应的 Access-Control-Allow-Origin 不能是通配符 * html代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; &lt;input type=\"submit\" onclick=\"XmlSendRequest();\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;input type=\"submit\" onclick=\"JqSendRequest();\" /&gt; &lt;/p&gt; &lt;script type=\"text/javascript\" src=\"jquery-1.12.4.js\"&gt;&lt;/script&gt; &lt;script&gt; function XmlSendRequest()&#123; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4) &#123; var result = xhr.responseText; console.log(result); &#125; &#125;; xhr.withCredentials = true; xhr.open('PUT', \"http://aylin.com:8000/test/\", true); xhr.setRequestHeader('k1', 'v1'); xhr.send(); &#125; function JqSendRequest()&#123; $.ajax(&#123; url: \"http://aylin.com:8000/test/\", type: 'PUT', dataType: 'text', headers: &#123;'k1': 'v1'&#125;, xhrFields:&#123;withCredentials: true&#125;, success: function(data, statusText, xmlHttpRequest)&#123; console.log(data); &#125; &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; view code代码 123456789101112131415161718192021复制代码class MainHandler(tornado.web.RequestHandler): def put(self): self.set_header('Access-Control-Allow-Origin', \"http://www.xxx.com\") self.set_header('Access-Control-Allow-Credentials', \"true\") self.set_header('xxoo', \"seven\") self.set_header('zhangyanlinhenshuai', \"feichangshuai\") self.set_header('Access-Control-Expose-Headers', \"shuai,shuaishuai\") self.set_cookie('kkkkk', 'vvvvv'); self.write('&#123;\"status\": true, \"data\": \"seven\"&#125;') def options(self, *args, **kwargs): self.set_header('Access-Control-Allow-Origin', \"http://www.xxx.com\") self.set_header('Access-Control-Allow-Headers', \"k1,k2\") self.set_header('Access-Control-Allow-Methods', \"PUT,DELETE\") self.set_header('Access-Control-Max-Age', 10)复制代码","categories":[{"name":"AJAX","slug":"AJAX","permalink":"http://yoursite.com/categories/AJAX/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://yoursite.com/tags/AJAX/"},{"name":"跨域，前后端数据交互","slug":"跨域，前后端数据交互","permalink":"http://yoursite.com/tags/跨域，前后端数据交互/"}]},{"title":"angularjs(一)","slug":"angular-1","date":"2017-04-25T05:17:02.000Z","updated":"2017-05-14T14:15:34.000Z","comments":true,"path":"2017/04/25/angular-1/","link":"","permalink":"http://yoursite.com/2017/04/25/angular-1/","excerpt":"","text":"正文开始1.前言 &#160; &#160; &#160; &#160;前端技术的发展是如此之快，各种优秀技术、优秀框架的出现简直让人目不暇接，紧跟时代潮流，学习掌握新知识自然是不敢怠慢。 &#160; &#160; &#160; &#160;AngularJS是google在维护，其在国外已经十分火热，可是国内的使用情况却有不小的差距，参考文献/网络文章也很匮乏。这里便将我学习AngularJS写成文档，一方面作为自己学习路程上的记录，另一方面也给有兴趣的同学一些参考。 &#160; &#160; &#160; &#160;首先我自己也是一名学习者，会以学习者的角度来整理我的行文思路，这里可能只是些探索，有理解或是技术上的错误还请大家指出；其次我特别喜欢编写小例子来把一件事情说明白，故在文中会尽可能多的用示例加代码讲解，我相信这会是一种比较好的方式；最后，我深知AngularJS的使用方式跟jQuery的使用方式有很大不同，在大家都有jquery、ext经验的条件下对于angular的学习会困难重重，不过我更相信在大家的坚持下，能够快速的学好AngularJS，至少咱也能深入了解到AngularJS的基本思想，对咱们以后自己的插件开发、项目开发都会有很大的启示。 2 AngularJS概述 2.1 AngularJS是什么？&#160; &#160; &#160; &#160;AngularJs（后面就简称ng了）是一个用于设计动态web应用的结构框架。首先，它是一个框架，不是类库，是像EXT一样提供一整套方案用于设计web应用。它不仅仅是一个JavaScript框架，因为它的核心其实是对HTML标签的增强。 &#160; &#160; &#160; &#160;何为HTML标签增强？其实就是使你能够用标签完成一部分页面逻辑，具体方式就是通过自定义标签、自定义属性等，这些HTML原生没有的标签/属性在ng中有一个名字：指令（directive）。后面会详细介绍。那么，什么又是动态web应用呢？与传统web系统相区别，web应用能为用户提供丰富的操作，能够随用户操作不断更新视图而不进行url跳转。ng官方也声明它更适用于开发CRUD应用，即数据操作比较多的应用，而非是游戏或图像处理类应用。 &#160; &#160; &#160; &#160;为了实现这些，ng引入了一些非常棒的特性，包括模板机制、数据绑定、模块、指令、依赖注入、路由。通过数据与模板的绑定，能够让我们摆脱繁琐的DOM操作，而将注意力集中在业务逻辑上。 &#160; &#160; &#160; &#160;另外一个疑问，ng是MVC框架吗？还是MVVM框架？官网有提到ng的设计采用了MVC的基本思想，而又不完全是MVC，因为在书写代码时我们确实是在用ng-controller这个指令(起码从名字上看，是MVC吧)，但这个controller处理的业务基本上都是与view进行交互，这么看来又很接近MVVM。让我们把目光移到官网那个非醒目的title上：“AngularJS — Superheroic JavaScript MVW Framework”。 2.2 AngularJS简单介绍&#160; &#160; &#160; &#160;AngularJS 重新定义了前端应用的开发方式。面对HTML和JavaScript之间的界线，它非但不畏缩不前，反而正面出击，提出了有效的解决方案。 &#160; &#160; &#160; &#160;很多前端应用的开发框架，比如Backbone、EmberJS等，都要求开发者继承此框架特有的一些JavaScript对象。这种方式有其长处，但它不必要地污染了开发者自己代码的对象空间，还要求开发者去了解内存里那些抽象对象。尽管如此我们还是接受了这种方式，因为网络最初的设计无法提供 我们今天所需的交互性，于是我们需要框架，来帮我们填补JavaScript和HTML之间的鸿沟。而且有了它，你不用再“直接”操控DOM，只要给你的DOM注上metadata（即AngularJS里的directive们），然后让AngularJS来帮你操纵DOM。同时，AngularJS不依赖（也不妨碍）任何其他的框架。你甚至可以基于其它的框架来开发AngularJS应用。API地址：http://docs.angularjs.org/api/；AngularJS在github上的中文粗译版地址：https://github.com/basestyle/angularjs-cn。 2.3 什么时候该用AngularJS&#160; &#160; &#160; &#160;AngularJS是一个 MV* 框架，最适于开发客户端的单页面应用。它不是个功能库，而是用来开发动态网页的框架。它专注于扩展HTML的功能，提供动态数据绑定（data binding），而且它能跟其它框架（如jQuery）合作融洽。 &#160; &#160; &#160; &#160;如果你要开发的是单页应用，AngularJS就是你的上上之选。Gmail、Google Docs、Twitter和Facebook这样的应用，都很能发挥AngularJS的长处。但是像游戏开发之类对DOM进行大量操纵、又或者单纯需要 极高运行速度的应用，就不是AngularJS的用武之地了。","categories":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://yoursite.com/categories/AngularJS/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yoursite.com/tags/angularjs/"},{"name":"angular介绍","slug":"angular介绍","permalink":"http://yoursite.com/tags/angular介绍/"}]},{"title":"Token ，Cookie和Session的区别","slug":"Token ，Cookie和Session的区别","date":"2017-04-25T05:17:02.000Z","updated":"2017-09-07T02:00:42.000Z","comments":true,"path":"2017/04/25/Token ，Cookie和Session的区别/","link":"","permalink":"http://yoursite.com/2017/04/25/Token ，Cookie和Session的区别/","excerpt":"","text":"正文开始Token ，Cookie和Session的区别 &#160; &#160; &#160; &#160;在做接口测试时，经常会碰到请求参数为token的类型，但是可能大部分测试人员对token，cookie，session的区别还是一知半解。为此我查阅大量的资料做了如下总结。 &#160; &#160; &#160; &#160;此篇文章也许是最全最通俗的关于Token ，Cookie和Session的区别的文章，好好揣摩文章的每一个字，也许你会有更深的理解！ Cookie&#160; &#160; &#160; &#160;cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。 &#160; &#160; &#160; &#160;cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。 Session&#160; &#160; &#160; &#160;session 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。 &#160; &#160; &#160; &#160;session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。 &#160; &#160; &#160; &#160;服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。 Token&#160; &#160; &#160; &#160;token的意思是“令牌”，是用户身份的验证方式，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免多次查库！ 传统身份验证&#160; &#160; &#160; &#160;HTTP 是一种没有状态的协议，也就是它并不知道是谁是访问应用。这里我们把用户看成是客户端，客户端使用用户名还有密码通过了身份验证，不过下回这个客户端再发送请求时候，还得再验证一下。 &#160; &#160; &#160; &#160;解决的方法就是，当用户请求登录的时候，如果没有问题，我们在服务端生成一条记录，这个记录里可以说明一下登录的用户是谁，然后把这条记录的 ID 号发送给客户端，客户端收到以后把这个 ID 号存储在 Cookie 里，下次这个用户再向服务端发送请求的时候，可以带着这个 Cookie ，这样服务端会验证一个这个 Cookie 里的信息，看看能不能在服务端这里找到对应的记录，如果可以，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。 &#160; &#160; &#160; &#160;上面说的就是 Session，我们需要在服务端存储为登录的用户生成的 Session ，这些 Session 可能会存储在内存，磁盘，或者数据库里。我们可能需要在服务端定期的去清理过期的 Session 。 基于 Token 的身份验证&#160; &#160; &#160; &#160;使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的： 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的Token，如果验证成功，就向客户端返回请求数据 &#160; &#160; &#160; &#160;APP登录的时候发送加密的用户名和密码到服务器，服务器验证用户名和密码，如果成功，以某种方式比如随机生成32位的字符串作为token，存储到服务器中，并返回token到APP，以后APP请求时，凡是需要验证的地方都要带上该token，然后服务器端验证token，成功返回所需要的结果，失败返回错误信息，让他重新登录。其中服务器上token设置一个有效期，每次APP请求的时候都验证token和有效期。 &#160; &#160; &#160; &#160;那么我的问题来了： 1.服务器上的token存储到数据库中，每次查询会不会很费时。如果不存储到数据库，应该存储到哪里呢。 2.客户端得到的token肯定要加密存储的，发送token的时候再解密。存储到数据库还是配置文件呢？ &#160; &#160; &#160; &#160;token是个易失数据，丢了无非让用户重新登录一下，新浪微博动不动就让我重新登录，反正这事儿我是无所谓啦。 &#160; &#160; &#160; &#160;所以如果你觉得普通的数据库表撑不住了，可以放到 MSSQL/MySQL 的内存表里（不过据说mysql的内存表性能提升有限），可以放到 Memcache里（讲真，这个是挺常见的策略），可以放到Redis里（我做过这样的实现），甚至可以放到 OpenResty 的变量字典里（只要你有信心不爆内存）。 &#160; &#160; &#160; &#160;token是个凭条，不过它比门票温柔多了，门票丢了重新花钱买，token丢了重新操作下认证一个就可以了，因此token丢失的代价是可以忍受的——前提是你别丢太频繁，要是让用户隔三差五就认证一次那就损失用户体验了。 &#160; &#160; &#160; &#160;基于这个出发点，如果你认为用数据库来保持token查询时间太长，会成为你系统的瓶颈或者隐患，可以放在内存当中。比如memcached、redis，KV方式很适合你对token查询的需求。&#160; &#160; &#160; &#160;这个不会太占内存，比如你的token是32位字符串，要是你的用户量在百万级或者千万级，那才多少内存。 &#160; &#160; &#160; &#160;要是数据量真的大到单机内存扛不住，或者觉得一宕机全丢风险大，只要这个token生成是足够均匀的，高低位切一下分到不同机器上就行，内存绝对不会是问题。 &#160; &#160; &#160; &#160;客户端方面这个除非你有一个非常安全的办法，比如操作系统提供的隐私数据存储，那token肯定会存在泄露的问题。比如我拿到你的手机，把你的token拷出来，在过期之前就都可以以你的身份在别的地方登录。 解决这个问题的一个简单办法: 1、在存储的时候把token进行对称加密存储，用时解开。2、将请求URL、时间戳、token三者进行合并加盐签名，服务端校验有效性。这两种办法的出发点都是：窃取你存储的数据较为容易，而反汇编你的程序hack你的加密解密和签名算法是比较难的。然而其实说难也不难，所以终究是防君子不防小人的做法。话说加密存储一个你要是被人扒开客户端看也不会被喷明文存储……方法1它拿到存储的密文解不开、方法2它不知道你的签名算法和盐，两者可以结合食用。但是如果token被人拷走，他自然也能植入到自己的手机里面，那到时候他的手机也可以以你的身份来用着，这你就瞎了。于是可以提供一个让用户可以主动expire一个过去的token类似的机制，在被盗的时候能远程止损。 在网络层面上token明文传输的话会非常的危险，所以建议一定要使用HTTPS，并且把token放在post body里。","categories":[{"name":"数据交互","slug":"数据交互","permalink":"http://yoursite.com/categories/数据交互/"}],"tags":[{"name":"cookie","slug":"cookie","permalink":"http://yoursite.com/tags/cookie/"},{"name":"Session","slug":"Session","permalink":"http://yoursite.com/tags/Session/"},{"name":"Token","slug":"Token","permalink":"http://yoursite.com/tags/Token/"}]},{"title":"angularjs(二)","slug":"angular-2","date":"2017-04-25T05:17:02.000Z","updated":"2017-05-14T14:15:30.000Z","comments":true,"path":"2017/04/25/angular-2/","link":"","permalink":"http://yoursite.com/2017/04/25/angular-2/","excerpt":"","text":"正文开始AugularJS特性 &#160; &#160; &#160; &#160;AngularJS是一个新出现的强大客户端技术，提供给大家的一种开发强大应用的方式。这种方式利用并且扩展HTML，CSS和javascript，并且弥补了它们的一些非常明显的不足。本应该使用HTML来实现而现在由它开发的动态一些内容。 AngularJS有五个最重要的功能和特性： 特性一：双向的数据绑定&#160; &#160; &#160; &#160;数据绑定可能是AngularJS最酷最实用的特性。它能够帮助你避免书写大量的初始代码从而节约开发时间。一个典型的web应用可能包含了80%的代码用来处理，查询和监听DOM。数据绑定是的代码更少，你可以专注于你的应用。 &#160; &#160; &#160; &#160;我们想象一下Model是你的应用中的简单事实。你的Model是你用来读取或者更新的部分。数据绑定指令提供了你的Model投射到view的方法。这些投射可以无缝的，毫不影响的应用到web应用中。 &#160; &#160; &#160; &#160;传统来说，当model变化了。 开发人员需要手动处理DOM元素并且将属性反映到这些变化中。这个一个双向的过程。一方面，model变化驱动了DOM中元素变化，另一方面，DOM元素的变化也会影响到Model。这个在用户互动中更加复杂，因为开发人员需要处理和解析这些互动，然后融合到一个model中，并且更新View。这是一个手动的复杂过程，当一个应用非常庞大的时候，将会是一件非常费劲的事情。 这里肯定有更好的解决方案！那就是AngularJS的双向数据绑定，能够同步DOM和Model等等。这里有一个非常简单的例子，用来演示一个input输入框和&lt; h1&gt;元素的双向绑定(例01)： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;angular双向数据绑定&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-app&gt; &lt;h1&gt;&#123;&#123;content&#125;&#125;&lt;/h1&gt; &lt;!-- 因为使用了双向绑定content指向的都是同一个值，所以h1的内容就是text输入框的内容 --&gt; &lt;input type=\"text\" name=\"\" ng-model=\"content\"&gt; &lt;!-- 设置双向绑定 --&gt; &lt;/div&gt; &lt;script src=\"http://code.angularjs.org/angular-1.0.1.min.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 特性二：模板&#160; &#160; &#160; &#160;在AngularJS中，一个模板就是一个HTML文件。但是HTML的内容扩展了，包含了很多帮助你映射model到view的内容。 &#160; &#160; &#160; &#160;HTML模板将会被浏览器解析到DOM中。DOM然后成为AngularJS编译器的输入。AngularJS将会遍历DOM模板来生成一些指导，即，directive（指令）。所有的指令都负责针对view来设置数据绑定。 &#160; &#160; &#160; &#160;我们要理解AuguarJS并不把模板当做String来操作。输入AngularJS的是DOM而非string。数据绑定是DOM变化，不是字符串的连接或者innerHTML变化。使用DOM作为输入，而不是字符串，是AngularJS区别于其它的框架的最大原因。使用DOM允许你扩展指令词汇并且可以创建你自己的指令，甚至开发可重用的组件。 &#160; &#160; &#160; &#160;最大的好处是为设计师和开发者创建了一个紧密的工作流。设计师可以像往常一样开发标签，然后开发者拿过来添加上功能，通过数据绑定将会使得这个过程非常简单。这里有一个例子，我们使用ng-repeat指令来循环图片数组并且加入img模板，如下： 12345678910111213141516function AlbumCtrl($scope) &#123; scope.images = [ &#123;\"image\":\"img/image_01.png\", \"description\":\"Image 01 description\"&#125;, &#123;\"image\":\"img/image_02.png\", \"description\":\"Image 02 description\"&#125;, &#123;\"image\":\"img/image_03.png\", \"description\":\"Image 03 description\"&#125;, &#123;\"image\":\"img/image_04.png\", \"description\":\"Image 04 description\"&#125;, &#123;\"image\":\"img/image_05.png\", \"description\":\"Image 05 description\"&#125; ];&#125;&lt;div ng-controller=\"AlbumCtrl\"&gt; &lt;ul&gt; &lt;li ng-repeat=\"image in images\"&gt; &lt;img ng-src=\"http://wangyuxuan.win/&#123;&#123;image.thumbnail&#125;&#125;\" rel=\"nofollow\"/&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; &#160; &#160; &#160; &#160;这里还有一件事值得提一句，AngularJS并不强制你学习一个新的语法或者从你的应用中提出你的模板。 特性三：MVC&#160; &#160; &#160; &#160;针对客户端应用开发AngularJS吸收了传统的MVC基本原则。MVC或者Model-View-Controll设计模式针对不同的人可能意味不同的东西。AngularJS并不执行传统意义上的MVC，更接近于MVVM（Moodel-View-ViewModel)。 Model &#160; &#160; &#160; &#160;model是应用中的简单数据。一般是简单的javascript对象。这里没有必要继承框架的classes，使用proxy对象封装或者使用特别的setter/getter方法来访问。事实上我们处理vanilla javascript的方法就是一个非常好的特性，这种方法使得我们更少使用应用的原型。 ViewModel &#160; &#160; &#160; &#160;viewmodel是一个用来提供特别数据和方法从而维护指定view的对象。viewmodel是$scope的对象，只存在于AnguarJS的应用中。$scope只是一个简单的js对象，这个对象使用简单的API来侦测和广播状态变化。 Controller &#160; &#160; &#160; &#160;controller负责设置初始状态和参数化$scope方法用以控制行为。需要指出的controller并不保存状态也不和远程服务互动。 View &#160; &#160; &#160; &#160;view是AngularJS解析后渲染和绑定后生成的HTML 。这个部分帮助你创建web应用的架构。$scope拥有一个针对数据的参考，controller定义行为，view处理布局和互动。 特性四：服务和依赖注入&#160; &#160; &#160; &#160;AngularJS服务其作用就是对外提供某个特定的功能。 &#160; &#160; &#160; &#160;AngularJS拥有内建的依赖注入（DI）子系统，可以帮助开发人员更容易的开发，理解和测试应用。 &#160; &#160; &#160; &#160;DI允许你请求你的依赖，而不是自己找寻它们。比如，我们需要一个东西，DI负责找创建并且提供给我们。 &#160; &#160; &#160; &#160;为了而得到核心的AngularJS服务，只需要添加一个简单服务作为参数，AngularJS会侦测并且提供给你：12345678910111213141516function EditCtrl($scope, $location, $routeParams) &#123; // Something clever here...&#125;你也可以定义自己的服务并且让它们注入：angular.module('MyServiceModule', []). factory('notify', ['$window', function (win) &#123; return function (msg) &#123; win.alert(msg); &#125;;&#125;]);function myController(scope, notifyService) &#123; scope.callNotify = function (msg) &#123; notifyService(msg); &#125;;&#125;myController.$inject = ['$scope', 'notify']; 特性五：指令（Directives）&#160; &#160; &#160; &#160;指令是我个人最喜欢的特性。你是不是也希望浏览器可以做点儿有意思的事情？那么AngularJS可以做到。 &#160; &#160; &#160; &#160;指令可以用来创建自定义的标签。它们可以用来装饰元素或者操作DOM属性。可以作为标签、属性、注释和类名使用。 这里是一个例子，它监听一个事件并且针对的更新它的$scope ，如下：123456789101112myModule.directive('myComponent', function(mySharedService) &#123; return &#123; restrict: 'E', controller: function($scope, $attrs, mySharedService) &#123; $scope.$on('handleBroadcast', function() &#123; $scope.message = 'Directive: ' + mySharedService.message; &#125;); &#125;, replace: true, template: '&lt;input&gt;' &#125;;&#125;); 然后，你可以使用这个自定义的directive来使用：1&lt;my-component ng-model=\"message\"&gt;&lt;/my-component&gt; 使用一系列的组件来创建你自己的应用将会让你更方便的添加，删除和更新功能。 小结:个人推荐一个学习angular.js的网站http://www.apjs.net/","categories":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://yoursite.com/categories/AngularJS/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yoursite.com/tags/angularjs/"},{"name":"AngularJS特性","slug":"AngularJS特性","permalink":"http://yoursite.com/tags/AngularJS特性/"}]},{"title":"angularjs(三)","slug":"angular-3","date":"2017-04-25T05:17:02.000Z","updated":"2017-05-14T14:15:28.000Z","comments":true,"path":"2017/04/25/angular-3/","link":"","permalink":"http://yoursite.com/2017/04/25/angular-3/","excerpt":"","text":"正文开始功能介绍 1.数据绑定&#160; &#160; &#160; &#160;AngularJS的双向数据绑定，意味着你可以在Mode(JS)中改变数据，而这些变动立刻就会自动出现在View上，反之亦然。即：一方面可以做到model变化驱动了DOM中元素变化，另一方面也可以做到DOM元素的变化也会影响到Model。&#160; &#160; &#160; &#160;在我们使用jQuery的时候，代码中会大量充斥类似这样的语句：var val = $(‘#id’).val(); $(‘#id’).html(str);等等，即频繁的DOM操作（读取和写入），其实我们的最终目的并不是要操作DOM，而是要实现业务逻辑。ng的绑定将让你摆脱DOM操作，只要模板与数据通过声明进行了绑定，两者将随时保持同步，最新的数据会实时显示在页面中，页面中用户修改的数据也会实时被记录在数据模型中。从View到Controller再到View的数据交互（例01）： 1&lt;html ng-app=\"demoApp\"&gt; 1&lt;input type=\"text\" ng-model=\"user.name\" placeholder=\"请输入名称\"/&gt; 1Hello, &#123;&#123; user.name &#125;&#125;！ 关键： ng-app 、 ng-model 和 { {user.name } }首先： 元素的ng-app属性。标识这个DOM里面的内容将启用AngularJS应用。其次：告诉AngularJS，对页面上的“user.name” 这个Model进行双向数据绑定。第三：告诉AngularJS，在“”这个指令模版上显示“user.name”这个Model的数据。从Server到Controller再到View的数据交互（例02）：1&lt;html ng-app=\"demoApp\"&gt; 123&lt;div ng-controller=\"demoController\"&gt;&lt;input type=\"text\" ng-model=\"user.name\" disabled=\"disabled\"/&gt;&lt;a href=\"javascript:void(0);\" target=\"_blank\" rel=\"nofollow\"&gt;获取名字&lt;/a&gt; 12345678demoApp.controller(\"demoController\", function($http, $scope)&#123;$scope. getAjaxUser = function()&#123;// $http.get(&#123;url:\"../xxx.action\"&#125;).success(function(data)&#123;// $scope.user= data;// &#125;);$scope.user = &#123;\"name\":\"从JOSN中获取的名称\",\"age\":22&#125;;&#125;;&#125;); 改变$scope中的user，View也会自动更新。 2.scopes、module、controller2.1 scopes&#160; &#160; &#160; &#160;$scope是一个把view（一个DOM元素）连结到controller上的对象。在我们的MVC结构里，这个 $scope 将成为model，它提供一个绑定到DOM元素（以及其子元素）上的excecution context。 &#160; &#160; &#160; &#160;尽管听起来有点复杂，但 $scope 实际上就是一个JavaScript对象，controller和view都可以访问它，所以我们可以利用它在两者间传递信息。在这个 $scope 对象里，我们既存储数据，又存储将要运行在view上的函数。 &#160; &#160; &#160; &#160;每一个Angular应用都会有一个 $rootScope。这个 $rootScope 是最顶级的scope，它对应着含有 ng-app 指令属性的那个DOM元素。1app.run(function($rootScope) &#123; $rootScope.name = \"张三\"; &#125;); &#160; &#160; &#160; &#160;如果页面上没有明确设定 $scope ，Angular 就会把数据和函数都绑定到这里， 第一部分中的例子就是靠这一点成功运行的。&#160; &#160; &#160; &#160;这样，我们就可以在view的任何地方访问这个name属性，使用模版表达式，像这样：1&#123;&#123;name&#125;&#125; 2.2 module&#160; &#160; &#160; &#160;首先需要明确一下模板的概念。在我还不知道有模板这个东西的时候，曾经用js拼接出很长的HTML字符串，然后append到页面中，这种方式想想真是又土又笨。后来又看到可以把HTML代码包裹在一个&lt;script&gt;标签中当作模板，然后按需要取来使用。&#160; &#160; &#160; &#160;在ng中，模板十分简单，它就是我们页面上的HTML代码，不需要附加任何额外的东西。在模板中可以使用各种指令来增强它的功能，这些指令可以让你把模板和数据巧妙的绑定起来。在&lt;html&gt;标签上多了一个属性ng-app=”MyApp”，它的作用就是用来指定ng的作用域是在&lt;html&gt;标签以内部分。在js中，我们调用angular对象的module方法来声明一个模块，模块的名字和ng-app的值对应。这样声明一下就可以让ng运行起来了。示例：12&lt;html ng-app=\"demoApp\"&gt;var demoApp = angular.module('demoApp', []); 2.3 ng-controller&#160; &#160; &#160; &#160;要明确创建一个$scope 对象，我们就要给DOM元素安上一个controller对象，使用的是ng-controller 指令属性：1&lt;div ng-controller=\"MyController\"&gt; &#123;&#123; person.name &#125;&#125; &lt;/div&gt; &#160; &#160; &#160; &#160;ng-controller指令给所在的DOM元素创建了一个新的$scope 对象，并将这个$scope 对象包含进外层DOM元素的$scope 对象里。在上面的例子里，这个外层DOM元素的$scope 对象，就是$rootScope 对象。这个scope链是这样的： &#160; &#160; &#160; &#160;所有scope都遵循原型继承（prototypal inheritance），这意味着它们都能访问父scope们。对任何属性和方法，如果AngularJS在当前scope上找不到，就会到父 scope上去找，如果在父scope上也没找到，就会继续向上回溯，一直到$rootScope 上。即如果controller是多层嵌套的，就会从最里面一直往外找，这个scope链是这样的： &#160; &#160; &#160; &#160;唯一的例外：有些指令属性可以选择性地创建一个独立的scope，让这个scope不继承它的父scope们，这个会在指令详解中说明。 4.3 ajax&#160; &#160; &#160; &#160;$http 服务是AngularJS的核心服务之一，它帮助我们通过XMLHttpRequest对象或JSONP与远程HTTP服务进行交流。&#160; &#160; &#160; &#160;$http 服务是这样一个函数：它接受一个设置对象，其中指定了如何创建HTTP请求；它将返回一个承诺（*参考JavaScript异步编程的promise模式），其中提供两个方法： success方法和error方法。 12345678910demoApp.controller(\"demoController\", function($http, $scope)&#123;$scope. getAjaxUser = function()&#123;$http.get(&#123;url:\"../xxx.action\"&#125;).success(function(data)&#123;alert(data);&#125;).error(function()&#123;Alert(“出错了！”);&#125;);&#125;;&#125;); AngularJS的AJAX与jquery等框架的AJAX基本一致，这里就不多说了。 4.4表达式&#160; &#160; &#160; &#160;ng中的表达式与javascript表达式类似但是不可以划等号，它是ng自己定义的一套模式。表达式可以作为指令的值，如1ng-modle=\"people.name\"、ng-click=\"showMe()\" ，看起来是如此像字符串，故而也叫字符串表达式。也可以在标记中使用表达式，如 1&#123;&#123;1+2&#125;&#125; ，或者与过滤器一起使用 1&#123;&#123;1+2 | currency&#125;&#125; 。在框架内部，字符串不会简单的使用eval()来执行，而是有一个专门的$parse服务来处理。在ng表达式中不可以使用循环语句、判断语句，事实上在模板中使用复杂的表达式也是一个不推荐的做法，这样视图与逻辑就混杂在一起了我们在使用其他模板库时，一般都会有模板的循环输出、分支输出、逻辑判断等类似的控制。要想理解指令属性的运作，我们必须先理解表达式。在之前的例子里我们已经见过表达式，例如1&#123;&#123; user.name &#125;&#125; 请查看例03、例04、例05。123&#123;&#123; 8 + 1 &#125;&#125; 9&#123;&#123; person &#125;&#125; &#123;\"name\":\"Ari Lerner\"&#125;&#123;&#123; 10 * 3.3 | currency &#125;&#125; $33.00 表达式粗略来看有点像 eval(javascript) 的结果。它们会经过Angular.js的处理，从而拥有以下重要而独特的性质：1 所有表达式都在scope这个context里被执行，因此可以使用所有本地 $scope 中的变量。2 如果一个表达式的执行导致类型错误或引用错误，这些错误将不会被抛出。3 表达式里不允许任何控制函数流程的功能（如if/else等条件语句）4 表达式可接受一个或多个串联起来的过滤器。","categories":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://yoursite.com/categories/AngularJS/"}],"tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/tags/前端框架/"},{"name":"angularjs","slug":"angularjs","permalink":"http://yoursite.com/tags/angularjs/"}]},{"title":"js对象的原型与继承方式","slug":"js对象的原型与继承方式","date":"2017-04-23T13:04:04.000Z","updated":"2017-09-07T02:01:02.000Z","comments":true,"path":"2017/04/23/js对象的原型与继承方式/","link":"","permalink":"http://yoursite.com/2017/04/23/js对象的原型与继承方式/","excerpt":"","text":"正文js对象的原型： 原型：就是指函数的prototype属性所引用的 对象 原型的作用：实现数据的共享 本质：原型 就是 对象；当创建函数时，就已经创建原型–js解析器创建的默认原型，会给默认原型添加一个constructor属性，该属性指回函数。 如果手动替换掉了默认的原型，那么constructor属性会丢失。此时，若该属性具有一定的开发意义，就将其手动添加上，并且给其正确的指向。 继承的概念 就是指对象有权去访问另一个对象上的属性和方法。 继承的实现 继承的基本实现：让一个对象 能 直接访问到另一个对象上的成员 继承实现方式 原型式：a: 在默认原型上 去添加 想要访问的属性和要调用的方法；b: 将默认的原型替换掉。然后原型变成一个新的对象，之后创建的对象，就继承自新的原型。 混入式：从jQuery的extend方法里总结的一种继承实现 混入式继承123456789101112131415161718192021222324// 在ES6，Object.assign()function extend( target ) &#123; var args = arguments, i = 1, l = args.length, obj; var k; if ( target == undefined ) &#123; return; &#125; for ( ; i &lt; l; i++ ) &#123; obj = args[ i ]; for ( k in obj ) &#123; if ( obj.hasOwnProperty( k ) ) &#123; target[ k ] = obj [ k ]; &#125; &#125; &#125; return target;&#125; 应用场景： &#160; &#160; &#160; &#160;在实际开发时，如果需要将参数以对象形式出入，并且在实际处理时需要将该对象的属性 在添加给其他对象来存储，那么在此时此景，就可以使用混入式继承来实现。 注意：虽然混入式继承不能实现代码的复用，但是在特定的情况下可以提高开发效率 ES5提供的方法扩展：Object.defineProperty(); Object.defineProperties() Object.create( parent, [options] ); 功能：创建一个对象，并继承自parent参数。可以通过第二个参数，给新对象初始化一些属性和方法 1234567891011121314151617181920var parent = &#123; say: function() &#123; console.log( 'hello, girl. I am ' + this.name + '. i am ' + this.age + ' years old. make friend, OK?' ); &#125;&#125;;var child = Object.create( parent, &#123; 'name': &#123; value: 'jingjing', writable: false, enumerable: true &#125;, 'age': &#123; value: 22, writable: true, enumerable: true &#125;&#125; );child.say(); 优点：非常方便的创建了一个对象，并继承了其他对象； 缺点：类型比较弱。 兼容处理： 创建新对象 新对象的原型 是 方法的parent参数 在兼容处理时，该方法从哪里来的 最终就添加到哪里去 12345678910// &lt;!-- 如果浏览器不支持该方法 --&gt;if ( !Object.create )&#123; Object.create = function ( parent ) &#123; function F() &#123; &#125; parent.constructor = F; F.prototype = parent; return new F(); &#125;;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"对象原型","slug":"对象原型","permalink":"http://yoursite.com/tags/对象原型/"},{"name":"js对象继承方式","slug":"js对象继承方式","permalink":"http://yoursite.com/tags/js对象继承方式/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2017-04-22T15:11:12.000Z","updated":"2017-09-07T02:01:20.000Z","comments":true,"path":"2017/04/22/正则表达式/","link":"","permalink":"http://yoursite.com/2017/04/22/正则表达式/","excerpt":"","text":"正则处理(正则，就是用来匹配的.)( regular expression)正则是由 正常的匹配字符 与 元字符( 通配符, 或格式化匹配 ) 构成的.因此正则表达式学习的就是元字符: 常用元字符:1) 基本元字符: . [] | () 2) 限定元字符: + * ? {n} {n,} {n,m} 3) 首尾元字符: ^ $ 4) 简写元字符: \\d \\D \\w \\W \\s \\S 贪婪模式:正则默认匹配尽可能匹配到的东西12&apos;1234567890&apos;/\\d+\\d+\\d+/ 取消贪婪模式: 在指定的限定元字符后面添加 ? 表示取消该限定元字符的贪婪模式 12&apos;1234567890&apos;/\\d+?\\d+\\d+/ 分组 分组( group ), 在正则中使用 () 来分组 1234567/(\\d+)(\\d+)(\\d+)/正则分组有一个规律, 从左往右数左圆括号, 编号从 1 开始,每一个与左圆括号结合的右圆括号构成一个区域. 该区域就是指定的组. 1 2 3/(\\d+)(\\d+)(\\d+)/ 1 2 3 4/(a(b(c)d))e(f)/ 123正则中有一个特殊的元字符不参与分组, 就是 (?: ) 1 2 3/(a(?:b(c)d))e(f)/ 正则常用方法: 正则是为了匹配字符串的, 那么可以匹配就可以提取, 可以提取就可以替换. test语法: 正则表达式.test( 字符串 ) =&gt; boolean验证数据常常被用到. exec提取字符串使用的语法: 正则表达式.exec( 字符串 ) =&gt; Array注意: 数组中的第 0 个元素则为匹配到的结果, 如果没有匹配到结果那么返回 null.默认只匹配提取从左往右找出来的第零个匹配项. 全局模式 -g如果要循环获得一个字符串中某一个匹配的字符串:1) 正则需要开启全局模式( 右边写上 g, 例如 /e/g )2) 依次调用 exec 方法会获得第0次, 第1次, 第2次的匹配结果, 直到找不到为止, 返回 null. 12345678eg: var str = 'ab12c12345d1ef123g45h67ijk3456lm89n'; // 将所有的数字取出来, 存储到数组中 var rnum = /\\d+/g; // 开启全局模式 var arr = [], // 存取到的数字字符串 m; // match while ( ( m = rnum.exec( str ) ) != null ) &#123; arr.push( m[ 0 ] - 0 ); &#125; replace语法: 字符串.replace( 正则表达式, ‘字符串’ ) =&gt; 新的字符串 eg:1123'a------------a---a------a-----a--a'.replace( /-+/g, '-' );=&gt; a-a-a-a-a-a 正则的 replace 方法中支持 组引用, 和组替换 eg:2123'a123bc'.replace( /(\\d+)/, '$1' ) =&gt; a123bc'a123bc'.replace( /(\\d+)/, '$1$1' ) =&gt; a123123bc eg:312'2017-4-21'.replace( /(\\d&#123;4&#125;)-(\\d&#123;1,2&#125;)-(\\d&#123;1,2&#125;)/, '$1年$2月$3日' ) eg:4123456/index.php/teacher/list =&gt; teacher-list/.+\\/(.+)\\/(.+)/'/index.php/teacher/list'.replace( /.+\\/(.+)\\/(.+)/, '.$1-$2' ) replace高级用法语法: 字符串.replace( 正则表达式, 回调函数 ) =&gt; 替换后的字符串 在执行的时候, 每次匹配到的结果, 都会将回调函数调用一次, 将回调函数的返回值 替换到 匹配项的位置. 12'a123b456c'.replace( /\\d+/g, function () &#123; return 'A'; &#125; ) 注意, 每次匹配到结果都会调用一次这个函数, 同时将匹配到的结果( 数组 )作为参数分散的传入到函数中.12'a123b456c'.replace( /\\d+/g, function ( m ) &#123; return m; &#125; )=&gt; a123b456c 带有回调函数的 replace 可以替代前面的所有 replace 的功能12345 'a------------a---a------a-----a--a'.replace( /-+/g, function () &#123; return '-'; &#125; );'2017-4-21'.replace( /(\\d&#123;4&#125;)-(\\d&#123;1,2&#125;)-(\\d&#123;1,2&#125;)/, function ( _, year, month, day ) &#123; return year + '年' + month + '月' + day + '日'; &#125;); 面试题将驼峰命名规则的字符串, 转换为带有连字符的字符串.12345678910111213141516171819'getElementsByTagName' =&gt; 'get-elements-by-tag-name'.//原生的实现方式var c = '??';c.charAt( 0 ).toUppercase() == c.charAt( 0 )c.charCode( 0 ) 在 65 与 91 之间//利用了正则的实现方式str.replace( /([a-z])([A-Z])/g, function ( _, a, b ) &#123; return a + '-' + b.toLowerCase();&#125;).replace( /([a-z])([A-Z])/g, function ( _, a, b ) &#123; return a + '-' + b.toLowerCase();&#125;);//反过来, get-elements-by-tag-name =&gt; getElementsByTagNamestr.replace( /(.)-(.)/g, function ( _, a, b ) &#123; return a + b.toUpperCase();&#125;); 总结：对于字符串处理来说，学会正则表达在日常开发中能够更快捷的处理各种字符串！","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"模块化开发的介绍与使用","slug":"模块化开发的介绍与使用","date":"2017-04-22T07:53:54.000Z","updated":"2017-09-07T02:00:06.000Z","comments":true,"path":"2017/04/22/模块化开发的介绍与使用/","link":"","permalink":"http://yoursite.com/2017/04/22/模块化开发的介绍与使用/","excerpt":"","text":"正文:模块的概念：所谓的模块, 在泛指的情况下与组件含义相同. 都是指组成一个完整系统一个零件或单体. &#160; &#160; &#160; &#160;所谓的前端模块化是为了使得前端页面中的内容可以复用( 思想, 将页面看成一个个零件组合而成 ) js 原生不支持模块化( 什么意思? )：1.每一个页面模块可以提供独立的 js 代码. 混合到一起后 数据无法共享或容易造成全局污染. 2.每一个 js 为了更好的使用会引入其他的 js. 那么不好统一处理依赖问题. 3.利用组件分解页面以后, 所有的数据是独立的,资源路径不容易统一维护. 因此需要提供一种 js 支持的 组件化方案：nodejs 平台中原生支持了 js 的模块化( CommonJS 规则 ) &#160; &#160; &#160; &#160;在 node 中如果要使用第三方的 js 代码, 就需要使用 require 来加载该代码( 此时与 html 中的 script 标签的功能一样 ) 1var code = require( '模块的名字' ) 将 node 的模块化思想移植到前端之中( 浏览器中 ) &#160; &#160; &#160; &#160;node 模块资源有一个特点, 就是存储在本地.node 在设计 api 的时候将 大部分 api 都设计成异步的. 但是require 是同步的. &#160; &#160; &#160; &#160;因此在浏览器中不能使用该规则的. 阻塞, 网络等一些列问题.所以为了解决这一系列的问题，引入了下面几种概念 AMD的概念：引入了一个新的规则 AMD( asynchronous module definition ), 开发了 require.js下载地址：[https://github.com/requirejs/requirejs] 在 require 很成功情况下, 它的语法有点问题( 提前加载 )123define( [ 所有的依赖 ], function () &#123;// 自己的代码&#125;); 特点是在执行自己的代码之前, 所有依赖必须加载完毕 CMD的概念：玉伯提出了按需的加载的思想, 引入了 CMD ( common module definition )规则, 开发了 sea.js下载地址：[https://github.com/seajs/seajs] 12345define( function () &#123;// 要用某一个模块的时候 require( '....' )require.async( ... )// 自己的代码&#125;); 思想就发生了变化编写代码不在统一的写道一个文件中, 而是写道不同的文件中, 称为模块然后再页面中组合成一个完整的代码来使用. 模块的定义与加载首先引入require.js1&lt;script src=\"./node_modules/requirejs/require.js\"&gt;&lt;/script&gt; 如何定义模块123define( '模块名', [ '依赖模块1'], function ( ) &#123; // 自己的模块&#125; 第一个参数是如果写了称该模块为表示的是匿名模块第二个参数是一个数组, 里面存储路径 )第三个参数是回调函数, 就如果有加载依注意: 一个模块应该定义到一个文件中, 一个文件中只允许有一个模块. 加载模块的语法1require( [ '模块名' ], function () &#123; &#125; ) &#160; &#160; &#160; &#160;加载模块的时候可以依次加载一个模块, 也可以依次加载多个模块, 使用数组描述即可第二个参数一般不需要, 它表示的是如果模块加载完成以后要立即使用, 则写在函数中. 定义自己的模块和引用定义自己的模块12345678&lt;script type=\"text/javascript\"&gt; define(function() &#123; console.log('wyx'); return &#123; name: 'hehe' &#125;&#125;);&lt;/script&gt; 引入自己的模块12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;自定义模块的引入&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"node_modules/requirejs/require.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; //可以引入自己自定义的模块 第二个参数是这个对象的变量 require(['./zdy'], function(name) &#123; console.log(name); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 模块的路径问题默认路径：&#160; &#160; &#160; &#160;RequireJS以一个相对于baseUrl的地址来加载所有的代码.页面顶层标签含有一个特殊的属性data-main，require.js使用它来启动脚本加载过程，而baseUrl一般设置到与该属性相一致的目录。下列示例中展示了baseUrl的设置 123&lt;!--This sets the baseUrl to the \"scripts\" directory, and loads a script that will have a module ID of 'main'--&gt;&lt;script data-main=\"scripts/main.js\" src=\"scripts/require.js\"&gt;&lt;/script&gt; &#160; &#160; &#160; &#160;baseUrl亦可通过RequireJS config手动设置。如果没有显式指定config及data-main，则默认的baseUrl为包含RequireJS的那个HTML页面的所属目录。 &#160; &#160; &#160; &#160;RequireJS默认假定所有的依赖资源都是js脚本，因此无需在module ID上再加”.js”后缀，RequireJS在进行module ID到path的解析时会自动补上后缀。你可以通过paths config设置一组脚本，这些有助于我们在使用脚本时码更少的字。 &#160; &#160; &#160; &#160;有时候你想避开”baseUrl + paths”的解析过程，而是直接指定加载某一个目录下的脚本。此时可以这样做：如果一个module ID符合下述规则之一，其ID解析会避开常规的”baseUrl + paths”配置，而是直接将其加载为一个相对于当前HTML文档的脚本： 以 “.js” 结束. 以 “/“ 开始. 包含 URL 协议, 如 “http:” or “https:” &#160; &#160; &#160; &#160;一般来说，最好还是使用baseUrl及”paths” config去设置module ID。它会给你带来额外的灵活性，如便于脚本的重命名、重定位等。 同时，为了避免凌乱的配置，最好不要使用多级嵌套的目录层次来组织代码，而是要么将所有的脚本都放置到baseUrl中. 自定义路径加载使用配置项123 require.config(&#123; baseUrl: '/参考路径'&#125;); 配置路径的短名字123456require.config(&#123; baseUrl: '基础路径', paths: &#123; 短名字: '长路径' &#125; &#125;) 命名模块的使用在定义模块的时候使用语法:12define( '模块名', [ 依赖 ], callback ) 具名模块, 或命名模块 named module必须配置路径, 在配置短名字的时候必须与模块的名字一样 如何导出依赖问题&#160; &#160; &#160; &#160;如果一个代码它依赖于另一个模块, 但是这个代码中没有定义依赖的方式, 那么就使用 添加一个 shim 的属性, 在属性中添加 deps 属性, 该值是一个数组 12345shim: &#123; 短名字: &#123; deps: [ '依赖的模块' ] &#125; &#125; 非模块的问题&#160; &#160; &#160; &#160;如果一个 js 库不是一个模块( 一个单纯的 js 库, 返回一个公共对象, 另一种就是为了完成某一个事情的 js 库, 不返回任何内容, 但是依赖于某一个库 )如果是返回对象的 js 库 使用配置12345shim: &#123; 短名字: &#123; exports: '名字' &#125; &#125; 总结&#160; &#160; &#160; &#160;写在最后的话，本文没有介绍AMD模式(sea.js)的使用方法，使用方法与require.js的使用方法大致相同，但是sea.js是采用了按需加载的模式(懒加载)，只有在调用时导入模块即可，具体用法如下 引入jquery为例12345define(function(require, exports, module) &#123; //引用jQuery模块 var $ = require('jquery');&#125;);","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"前端模块化","slug":"前端模块化","permalink":"http://yoursite.com/tags/前端模块化/"},{"name":"requirejs","slug":"requirejs","permalink":"http://yoursite.com/tags/requirejs/"},{"name":"seajs","slug":"seajs","permalink":"http://yoursite.com/tags/seajs/"}]}]}